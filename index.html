<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tetris Builder</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp,container-queries"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js" integrity="sha512-Siyxh4Wv/7aUNJTSrWpeBCkfBGqtqJDDvHywNMoq7Xq3gufdWbx0qIYr0T4D9zXGj2FXqQJ48YEoPChsCE7MAg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        :root { /* Define CSS Variables for UI Theming */
            --panel-bg: rgba(50, 50, 50, 0.85);
            --panel-border: rgba(100, 116, 139, 0.7); /* slate-500 */
            --text-color: #e5e7eb; /* gray-200 */
            --text-color-muted: #9ca3af; /* gray-400 */
            --text-color-heading: #f3f4f6; /* gray-100 */
            --button-bg: #4b5563; /* gray-600 */
            --button-border: #6b7280; /* gray-500 */
            --button-hover-bg: #374151; /* gray-700 */
            --button-active-bg: #1f2937; /* gray-800 */
            --accent-color: #3b82f6; /* blue-500 */
            --font-main: 'Inter', sans-serif; /* Keep Inter for body */
            --font-display: 'Press Start 2P', cursive; /* Use block font for UI */
        }

        body { margin: 0; overflow: hidden; font-family: var(--font-main); background-color: #111827; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas { display: block; }

        /* --- Overlays --- */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(17, 24, 39, 0.95); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-color-heading); text-align: center; padding: 1rem; font-family: var(--font-display); overflow-y: auto; }
        #welcome-screen { /* Starts visible */ }
        #main-menu-screen { display: none; /* Hidden initially */ }
        #help-screen { display: none; /* Hidden initially */ justify-content: flex-start; padding-top: 3rem; }

        /* Welcome Screen Specifics */
        #welcome-screen h1 { font-size: 1.8rem; line-height: 1.4; font-weight: normal; margin-bottom: 1rem; color: #fff; }
        #welcome-screen p { font-size: 0.8rem; line-height: 1.5; color: var(--text-color-muted); margin-bottom: 2rem; }
        #player-name { padding: 0.75rem 1rem; font-size: 0.8rem; border-radius: 0.5rem; border: 1px solid var(--panel-border); background-color: rgba(255, 255, 255, 0.1); color: var(--text-color-heading); margin-bottom: 1.5rem; width: 100%; max-width: 300px; text-align: center; font-family: var(--font-main); }
        #player-name::placeholder { color: var(--text-color-muted); }
        #start-game-button { padding: 0.75rem 2rem; font-size: 0.9rem; font-weight: normal; border-radius: 0.5rem; background-color: var(--accent-color); color: white; border: none; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-family: var(--font-display); }
         #start-game-button:hover { background-color: #2563eb; }
         #start-game-button:active { transform: scale(0.98); }

        /* Main Menu Specifics */
        #main-menu-screen h1 { font-size: 1.8rem; line-height: 1.4; font-weight: normal; margin-bottom: 2.5rem; color: #fff; }
        .menu-button { padding: 0.6rem 1.5rem; font-size: 1rem; font-weight: normal; border-radius: 0.5rem; background-color: var(--button-bg); color: var(--text-color-heading); border: 1px solid var(--button-border); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-family: var(--font-display); margin-bottom: 1rem; width: 250px; display: block; margin-left: auto; margin-right: auto; }
        .menu-button:hover { background-color: var(--button-hover-bg); transform: translateY(-1px); }
        .menu-button:active { background-color: var(--button-active-bg); transform: scale(0.98); }

        /* Help Screen Specifics */
         #help-screen-content { max-width: 600px; text-align: left; font-size: 0.75rem; line-height: 1.6; color: var(--text-color); }
         #help-screen h2 { font-size: 1.5rem; color: #fff; margin-bottom: 1.5rem; text-align: center; }
         #help-screen h4 { font-size: 0.9rem; color: var(--text-color-heading); margin-top: 1.5rem; margin-bottom: 0.5rem; }
         #help-screen p, #help-screen li { margin-bottom: 0.5rem; color: var(--text-color); }
         #help-screen ul { list-style: none; padding-left: 0; }
         #help-screen code { background-color: rgba(0,0,0,0.3); padding: 0.1em 0.4em; border-radius: 4px; font-family: monospace; color: #facc15; }
         #close-help-button { margin-top: 2rem; padding: 0.6rem 1.5rem; font-size: 0.9rem; font-weight: normal; border-radius: 0.5rem; background-color: var(--accent-color); color: white; border: none; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-family: var(--font-display); display: block; margin-left: auto; margin-right: auto; }
         #close-help-button:hover { background-color: #2563eb; }
         #close-help-button:active { transform: scale(0.98); }


        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 1rem; color: var(--text-color); pointer-events: none; display: none; font-family: var(--font-display); font-size: 8px; }
        .ui-panel { background-color: var(--panel-bg); border: 1px solid var(--panel-border); padding: 0.75rem 1rem; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1); pointer-events: auto; width: fit-content; margin-bottom: 0.75rem; position: absolute; transition: background-color 0.3s ease, border-color 0.3s ease; }

        /* Panel Positions */
        #mission-info { line-height: 1.5; top: 1rem; left: 1rem; }
        #controls-info { bottom: 1rem; left: 1rem; font-size: 1em; }
        .ui-controls { pointer-events: auto; display: flex; gap: 0.5rem; position: absolute; top: 1rem; right: 1rem; }
        #right-column { position: absolute; top: calc(1rem + 40px + 0.5rem); right: 1rem; display: flex; flex-direction: column; align-items: flex-end; gap: 0.75rem; pointer-events: none; width: 224px; }
        #right-column .ui-panel { position: static; width: 100%; box-sizing: border-box; }
        #preview-box { text-align: center; }
        #theme-selector { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; padding: 0.75rem; }
        #lighting-controls { font-size: 1em; padding: 0.75rem; }

        /* Headings and Text */
        .ui-panel h2 { font-size: 1.2em; font-weight: normal; color: var(--text-color-heading); margin-bottom: 0.25rem; line-height: 1.2; }
        .ui-panel h3 { width: 100%; margin-bottom: 0.75rem; font-weight: normal; font-size: 1em; color: var(--text-color-muted); text-align: left; border-bottom: 1px solid var(--panel-border); padding-bottom: 0.25rem; line-height: 1.2; }
        #score-display { font-weight: normal; font-size: 1.3em; color: #facc15; }
        .ui-panel p { font-size: 1em; line-height: 1.4; margin-bottom: 0.25rem;}
        #controls-info strong { font-weight: normal; }

        /* Buttons */
        .game-button { padding: 0.5rem 1rem; border-radius: 0.5rem; background-color: var(--button-bg); color: var(--text-color-heading); font-weight: normal; border: 1px solid var(--button-border); height: 40px; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); transition: all 0.15s ease-out; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 1em; white-space: nowrap; }
        .game-button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
        .game-button:active:not(:disabled) { background-color: var(--button-active-bg); transform: scale(0.98); }
        .game-button:disabled { background-color: #374151; border-color: #4b5563; color: #9ca3af; cursor: not-allowed; transform: none; box-shadow: none; opacity: 0.6; }
        #ai-help-button { min-width: 100px; }

        .theme-button { padding: 0.5rem 0.6rem; font-size: 1em; border-radius: 0.375rem; background-color: #5a6578; color: white; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; cursor: pointer; border: 1px solid #718096; text-align: center; width: 100%; line-height: 1.1; }
        .theme-button:hover { background-color: #3d4758; }
        .theme-button.active { background-color: var(--accent-color); border-color: var(--accent-color); font-weight: normal; }

        /* Lighting Controls Styling */
        #lighting-controls label { display: block; margin-bottom: 0.1rem; color: var(--text-color-muted); font-size: 1em; line-height: 1.2; }
        #lighting-controls div { margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: space-between; }
        #lighting-controls label { flex-basis: 45%; flex-shrink: 0; }
        #lighting-controls input[type="range"] { flex-grow: 1; width: auto; height: 8px; cursor: pointer; accent-color: var(--accent-color); margin: 0 0.5rem; }
        #lighting-controls span { display: inline-block; min-width: 2.5em; text-align: right; color: var(--text-color-heading); font-size: 1em; }

        #preview-canvas { width: 80px; height: 80px; border-radius: 0.375rem; background-color: rgba(0, 0, 0, 0.2); margin: 0 auto; }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.5rem 2.5rem; border-radius: 0.75rem; font-size: 1.2rem; text-align: center; display: none; z-index: 10; pointer-events: none; font-family: var(--font-display); line-height: 1.4; }

    </style>
</head>
<body>
    <div id="welcome-screen" class="overlay">
        <h1>3D Tetris Builder</h1>
        <p>Construct the blueprints before the blocks pile up!</p>
        <input type="text" id="player-name" placeholder="Enter your name" maxlength="20">
        <button id="start-game-button">Continue</button><br>
        <p>Developed by SAFR+!</p>
    </div>

    <div id="main-menu-screen" class="overlay">
        <h1>MAIN MENU</h1>
        <button id="menu-start-button" class="menu-button">Start Game</button>
        <button id="menu-demo-button" class="menu-button">Demo</button>
        <button id="menu-help-button" class="menu-button">Help</button>
    </div>

    <div id="help-screen" class="overlay">
        <div id="help-screen-content">
            <h2>How to Play</h2>
            <h4>Goal</h4> <p>Complete the building blueprints for each mission. Falling blocks must be placed to fill the exact spots indicated by the semi-transparent 'ghost' blocks.</p>
            <h4>Controls</h4> <ul> <li><code>W</code> / <code>S</code>: Move block Forward / Backward (Z-axis)</li> <li><code>A</code> / <code>D</code>: Move block Left / Right (X-axis)</li> <li><code>Spacebar</code>: Rotate block (Y-axis)</li> <li><code>ArrowDown</code>: Speed up block fall</li> <li><code>P</code>: Pause / Resume game</li> <li><code>R</code>: Return to Main Menu</li> <li><code>H</code>: Use AI Hint (see below)</li> <li>Mouse Drag: Rotate camera view</li> </ul>
            <h4>Gameplay</h4> <p>Use the controls to position the falling block. When a block lands on the ground or another block, it locks into place. If a locked block occupies a space shown in the blueprint, the corresponding ghost block will disappear. Complete the mission by filling all ghost block spots.</p>
            <h4>Scoring</h4> <ul> <li>+10 Points per cube locked.</li> <li>+50 Bonus points per cube locked in a correct blueprint spot.</li> <li>+500 Bonus points for completing a mission.</li> <li>Up to +1000 Time Bonus per mission based on speed.</li> <li>-200 Points penalty for using AI Hint.</li> </ul>
            <h4>AI Hint</h4> <ul> <li>Shows the best calculated spot for the *next* piece.</li> <li>Target ghost blocks will blink for 5 seconds.</li> <li>Costs 200 points per use.</li> <li>Limited to 3 uses per game.</li> <li>Available only after placing 3 correct blocks in a mission.</li> <li>Activate with the 'H' key or the button.</li> </ul>
            <h4>Other Features</h4> <ul> <li>Use the Theme buttons to change the visual style.</li> <li>Use the Lighting sliders to adjust the scene lighting.</li> </ul>
            <button id="close-help-button">Close</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="ui-overlay"> <div id="mission-info" class="ui-panel">
                <h2>Mission: <span id="mission-name">Loading...</span></h2>
                <p>Blocks Placed: <span id="blocks-placed">0</span> / <span id="blocks-target">0</span></p>
                <p>Score: <span id="score-display">0</span></p>
            </div>
            <div class="ui-controls">
                 <button id="ai-help-button" class="game-button">AI Hint (3)</button>
                 <button id="pause-button" class="game-button">Pause</button>
                 <button id="restart-button" class="game-button">Main Menu</button>
            </div>
            <div id="right-column">
                 <div id="preview-box" class="ui-panel"> <h3>Next</h3> <canvas id="preview-canvas"></canvas> </div>
                 <div id="theme-selector" class="ui-panel"> <h3>Theme</h3> <button class="theme-button" data-theme="default">Default</button> <button class="theme-button" data-theme="milkyway">Stars</button> <button class="theme-button" data-theme="cyberpunk">Cyber</button> <button class="theme-button" data-theme="jungle">Jungle</button> <button class="theme-button" data-theme="town">Town</button> </div>
                 <div id="lighting-controls" class="ui-panel"> <h3>Lights</h3> <div><label for="hemi-intensity">Hemi:</label><input type="range" id="hemi-intensity" name="hemi-intensity" min="0" max="3" step="0.1"><span id="hemi-intensity-value">1.0</span></div> <div><label for="ambient-intensity">Amb:</label><input type="range" id="ambient-intensity" name="ambient-intensity" min="0" max="2" step="0.1"><span id="ambient-intensity-value">1.0</span></div> <div><label for="dir-intensity">Sun:</label><input type="range" id="dir-intensity" name="dir-intensity" min="0" max="5" step="0.1"><span id="dir-intensity-value">1.0</span></div> <div><label for="dir-y">Angle:</label><input type="range" id="dir-y" name="dir-y" min="1" max="30" step="1"><span id="dir-y-value">15</span></div> </div>
            </div>
            <div id="controls-info" class="ui-panel"> <strong>Controls:</strong> WASD(Move), Space(Rotate), P, R(Menu), H(Hint) </div>
        </div>
        <div id="message-box">Message</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        // ... (constants remain the same)
        const BOARD_WIDTH = 10; const BOARD_HEIGHT = 20; const BOARD_DEPTH = 10; const CUBE_SIZE = 1; const FALL_SPEED_NORMAL = 1000; const FALL_SPEED_FAST = 50; const LOCK_FLASH_DURATION = 250; const PARTICLE_COUNT = 50; const PARTICLE_LIFESPAN = 0.5; const PREVIEW_CANVAS_SIZE = 80; const POINTS_PER_CUBE = 10; const POINTS_PER_CORRECT_CUBE_BONUS = 50; const POINTS_MISSION_COMPLETE = 500; const MAX_TIME_BONUS = 1000; const MAX_TIME_ALLOWED_PER_MISSION = 120; const STARFIELD_RADIUS = 200; const STARFIELD_COUNT = 5000; const AI_HINT_USES = 3; const AI_HINT_COST = 200; const AI_HINT_ACTIVATE_THRESHOLD = 3; const HINT_BLINK_DURATION = 5000; const HINT_BLINK_INTERVAL = 300; const DEMO_STEP_DELAY = 400; // ms between demo steps


        // --- Game State ---
        // ... (game state variables remain the same, add isDemoMode)
        let scene, camera, renderer, controls, clock;
        let board = []; let currentPiece = null; let ghostBlocks = [];
        let lockedBlocksGroup = new THREE.Group(); let currentMissionIndex = 0;
        let fallInterval; let currentFallSpeed = FALL_SPEED_NORMAL;
        let targetBlockCount = 0; let placedTargetBlocks = 0;
        let isGameOver = false; let isPaused = false; let activeParticles = [];
        let nextPieceData = null; let totalScore = 0; let missionStartTime = 0;
        let gameStarted = false; let playerName = "Player";
        let aiHintUsesLeft = AI_HINT_USES;
        let isBlinkingHint = false; let blinkingGhostsInfo = []; let blinkIntervalId = null;
        let isDemoMode = false; // Flag for demo mode
        let demoTimeoutId = null; // Timeout ID for demo steps


        // --- Scene Elements ---
        // ... (scene elements remain the same)
        let hemisphereLight, ambientLight, directionalLight, groundPlane;
        let starfield = null;

        // --- Preview Scene State ---
        // ... (preview state remains the same)
        let previewScene, previewCamera, previewRenderer, previewPieceMesh = null;


        // --- Audio ---
        // ... (audio variables remain the same)
        let synthMove, synthRotate, synthLock, synthCorrectLock, synthMissionComplete;
        let audioReady = false;


        // DOM Elements
        // ... (add new help elements)
        let pauseButton, restartButton, messageBox, previewCanvas, scoreDisplay, themeButtons, aiHelpButton;
        let hemiIntensitySlider, ambientIntensitySlider, dirIntensitySlider, dirYSlider;
        let hemiIntensityValueSpan, ambientIntensityValueSpan, dirIntensityValueSpan, dirYValueSpan;
        let welcomeScreen, playerNameInput, startGameButton, uiOverlay;
        let mainMenuScreen, menuStartButton, menuDemoButton, menuHelpButton;
        let helpScreen, closeHelpButton; // New Help Elements


        // --- Loaders ---
        // ... (loaders remain the same)
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();


        // --- Textures ---
        // ... (textures remain the same)
        let groundTexture = null;


        // --- Helper Function for Placeholder Skybox URLs ---
        function createPlaceholderSkybox(bC,tC,p=''){const s=256; return [`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PZ`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NZ`];}

        // --- Theme Definitions (with UI colors) ---
        // ... (themes remain the same)
        const themes = { default: { background: new THREE.Color(0x333340), skybox: null, starfield: false, fog: { color: 0x333340, near: BOARD_DEPTH * 1.5, far: BOARD_DEPTH * 3 }, lights: { hemiSky: 0xadcafc, hemiGround: 0x404040, hemiIntensity: 1.5, ambient: 0xffffff, ambientIntensity: 0.3, dir: 0xffffff, dirIntensity: 2.0, dirY: 15 }, groundColor: 0xaaaaaa, ui: { panelBg: 'rgba(50, 50, 64, 0.85)', panelBorder: 'rgba(100, 116, 139, 0.7)', textColor: '#e5e7eb', textColorMuted: '#9ca3af', textColorHeading: '#f3f4f6', accent: '#60a5fa' } }, milkyway: { background: new THREE.Color(0x000005), skybox: null, starfield: true, fog: null, lights: { hemiSky: 0x303050, hemiGround: 0x101020, hemiIntensity: 0.5, ambient: 0x404060, ambientIntensity: 0.15, dir: 0xaaaaff, dirIntensity: 0.8, dirY: 10 }, groundColor: 0x222222, ui: { panelBg: 'rgba(10, 10, 20, 0.85)', panelBorder: 'rgba(70, 70, 100, 0.7)', textColor: '#a0a0c0', textColorMuted: '#707090', textColorHeading: '#c0c0e0', accent: '#aaaaff' } }, cyberpunk: { background: new THREE.Color(0x1a0a2a), skybox: createPlaceholderSkybox('1a0a2a', 'FF00FF', 'CYBER_'), starfield: false, fog: { color: 0xff00ff, near: BOARD_DEPTH * 1.2, far: BOARD_DEPTH * 2.8 }, lights: { hemiSky: 0x00aaff, hemiGround: 0xff00aa, hemiIntensity: 1.8, ambient: 0x8888ff, ambientIntensity: 0.4, dir: 0x00ffff, dirIntensity: 1.8, dirY: 20 }, groundColor: 0x440044, ui: { panelBg: 'rgba(40, 10, 60, 0.9)', panelBorder: 'rgba(255, 0, 255, 0.5)', textColor: '#f0f', textColorMuted: '#a0a', textColorHeading: '#fff0ff', accent: '#0ff' } }, jungle: { background: new THREE.Color(0x305020), skybox: createPlaceholderSkybox('305020', 'b0d0a0', 'JUNGLE_'), starfield: false, fog: { color: 0x305020, near: BOARD_DEPTH * 0.7, far: BOARD_DEPTH * 2.2 }, lights: { hemiSky: 0xb0d0a0, hemiGround: 0x406030, hemiIntensity: 1.2, ambient: 0xeeeecc, ambientIntensity: 0.6, dir: 0xffffcc, dirIntensity: 1.5, dirY: 12 }, groundColor: 0x556B2F, ui: { panelBg: 'rgba(48, 80, 32, 0.9)', panelBorder: 'rgba(85, 107, 47, 0.7)', textColor: '#d0e0c0', textColorMuted: '#80a070', textColorHeading: '#f0fff0', accent: '#90ee90' } }, town: { background: new THREE.Color(0x87CEEB), skybox: createPlaceholderSkybox('87CEEB', 'FFFFFF', 'TOWN_'), starfield: false, fog: { color: 0xcccccc, near: BOARD_DEPTH * 2.0, far: BOARD_DEPTH * 4.0 }, lights: { hemiSky: 0xffffff, hemiGround: 0xaaaaaa, hemiIntensity: 1.8, ambient: 0xffffff, ambientIntensity: 0.6, dir: 0xffffee, dirIntensity: 2.2, dirY: 18 }, groundColor: 0xbbbbbb, ui: { panelBg: 'rgba(220, 220, 220, 0.85)', panelBorder: 'rgba(180, 180, 180, 0.7)', textColor: '#444', textColorMuted: '#777', textColorHeading: '#222', accent: '#4299e1' } } };
        let currentTheme = 'default';

        // --- Mission Definitions --- (Shortened)
        const missions = [ { name: "1", d:{x:4,y:1,z:4}, b: generateSolidBlueprint(4,1,4) }, { name: "2", d:{x:4,y:1,z:4}, b: generateWallBlueprint(4,1,4) }, { name: "3", d:{x:1,y:5,z:1}, b: generateSolidBlueprint(1,5,1) }, { name: "4", d:{x:4,y:2,z:4}, b: generateHollowBlueprint(4,2,4) }, { name: "5", d:{x:5,y:3,z:1}, b: generateArchBlueprint(5,3,1) } ];
        // --- Tetromino Definitions --- (Shortened)
        const TETROMINOES = {'I':{c:0x00FFFF,s:[[0,0,0],[-1,0,0],[1,0,0],[2,0,0]]},'O':{c:0xFFFF00,s:[[0,0,0],[1,0,0],[0,1,0],[1,1,0]]},'T':{c:0x800080,s:[[0,0,0],[-1,0,0],[1,0,0],[0,1,0]]},'L':{c:0xFFA500,s:[[0,0,0],[-1,0,0],[1,0,0],[1,1,0]]},'J':{c:0x0000FF,s:[[0,0,0],[-1,0,0],[1,0,0],[-1,1,0]]},'S':{c:0x00FF00,s:[[0,0,0],[-1,0,0],[0,1,0],[1,1,0]]},'Z':{c:0xFF0000,s:[[0,0,0],[1,0,0],[0,1,0],[-1,1,0]]}}; const TETROMINO_KEYS = Object.keys(TETROMINOES);
        // --- Blueprint Generation Helpers --- (Shortened)
        function getBlueprintOffset(w,d){ return {x:Math.floor((BOARD_WIDTH-w)/2), z:Math.floor((BOARD_DEPTH-d)/2)}; } function generateSolidBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateWallBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) if(x===0||x===w-1||z===0||z===d-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateHollowBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) if(x===0||x===w-1||z===0||z===d-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateArchBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); const ph=h-1; const sy=ph; if(w<3) return generateSolidBlueprint(w,h,d); for(let y=0;y<ph;y++){ for(let z=0;z<d;z++) b.push({x:o.x,y:y,z:z+o.z}); for(let z=0;z<d;z++) b.push({x:o.x+w-1,y:y,z:z+o.z}); } for(let x=0;x<w;x++) for(let z=0;z<d;z++) b.push({x:x+o.x,y:sy,z:z+o.z}); return b; }

        // --- Initialization ---
        function init() {
            clock = new THREE.Clock();
            // Get UI Elements
            uiOverlay = document.getElementById('ui-overlay'); pauseButton = document.getElementById('pause-button'); restartButton = document.getElementById('restart-button'); messageBox = document.getElementById('message-box'); previewCanvas = document.getElementById('preview-canvas'); scoreDisplay = document.getElementById('score-display'); themeButtons = document.querySelectorAll('.theme-button'); aiHelpButton = document.getElementById('ai-help-button'); welcomeScreen = document.getElementById('welcome-screen'); playerNameInput = document.getElementById('player-name'); startGameButton = document.getElementById('start-game-button');
            // Menu Elements
            mainMenuScreen = document.getElementById('main-menu-screen'); menuStartButton = document.getElementById('menu-start-button'); menuDemoButton = document.getElementById('menu-demo-button'); menuHelpButton = document.getElementById('menu-help-button');
            // Help Screen Elements
            helpScreen = document.getElementById('help-screen'); closeHelpButton = document.getElementById('close-help-button');
            // Lighting Control Elements
            hemiIntensitySlider = document.getElementById('hemi-intensity'); ambientIntensitySlider = document.getElementById('ambient-intensity'); dirIntensitySlider = document.getElementById('dir-intensity'); dirYSlider = document.getElementById('dir-y'); hemiIntensityValueSpan = document.getElementById('hemi-intensity-value'); ambientIntensityValueSpan = document.getElementById('ambient-intensity-value'); dirIntensityValueSpan = document.getElementById('dir-intensity-value'); dirYValueSpan = document.getElementById('dir-y-value');

            // --- Initialize Audio Synths ---
            setupAudio();

            // --- Main Scene Setup ---
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(BOARD_WIDTH/2, BOARD_HEIGHT*0.8, BOARD_DEPTH*1.6); camera.lookAt(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2); renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0;

            // --- Create Lights ---
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.0); scene.add(hemisphereLight); ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight); directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(8, 15, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; const shadowCamSize = Math.max(BOARD_WIDTH, BOARD_DEPTH)*0.8; directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize; directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize; directionalLight.shadow.bias = -0.0005; scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement); controls.target.set(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2); controls.enablePan = true; controls.maxPolarAngle = Math.PI/2 - 0.05; controls.minDistance = 5; controls.maxDistance = 50; controls.enableDamping = true; controls.dampingFactor = 0.05; controls.update();
            loadTextures(); createBoardVisuals();
            lockedBlocksGroup.castShadow = true; lockedBlocksGroup.receiveShadow = true; scene.add(lockedBlocksGroup);
            initBoard(); initPreviewRenderer();

            // --- Apply Default Theme (before game starts) ---
            applyTheme('default');

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            pauseButton.addEventListener('click', togglePause);
            restartButton.addEventListener('click', goToMainMenu); // Use new function
            aiHelpButton.addEventListener('click', useAiHint);
            themeButtons.forEach(button => { button.addEventListener('click', () => { applyTheme(button.dataset.theme); }); });
            hemiIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); hemisphereLight.intensity=v; hemiIntensityValueSpan.textContent=v.toFixed(1); }); ambientIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); ambientLight.intensity=v; ambientIntensityValueSpan.textContent=v.toFixed(1); }); dirIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.intensity=v; dirIntensityValueSpan.textContent=v.toFixed(1); }); dirYSlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.position.y=v; dirYValueSpan.textContent=v.toFixed(0); });
            // Welcome Screen Button
            startGameButton.addEventListener('click', showMainMenu);
            playerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') showMainMenu(); });
            // Main Menu Buttons
            menuStartButton.addEventListener('click', () => {
                mainMenuScreen.style.display = 'none';
                initializeAndStartGameplay(); // Start normal game
            });
             menuDemoButton.addEventListener('click', () => {
                 mainMenuScreen.style.display = 'none';
                 initializeAndStartGameplay(true); // Start demo mode
             });
             menuHelpButton.addEventListener('click', () => {
                 // Show Help Screen
                 mainMenuScreen.style.display = 'none';
                 helpScreen.style.display = 'flex';
             });
             // Help Screen Close Button
             closeHelpButton.addEventListener('click', () => {
                 helpScreen.style.display = 'none';
                 mainMenuScreen.style.display = 'flex'; // Go back to main menu
             });

            animate(); // Start rendering loop
        }

        // Renamed from startGame
        async function initializeAndStartGameplay(demo = false) { // Added demo flag
             // --- Start Audio Context ---
             if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') { try { await Tone.start(); audioReady = true; console.log('Audio context started!'); } catch (error) { console.error("Failed to start Tone.js audio context:", error); audioReady = false; } } else if (typeof Tone !== 'undefined' && Tone.context.state === 'running') { audioReady = true; } else { console.warn("Tone.js library not loaded."); audioReady = false; }
             // ---

            uiOverlay.style.display = 'block'; // Show game UI

            isDemoMode = demo; // Set demo mode flag
            gameStarted = true; isPaused = false; isGameOver = false;
            totalScore = 0; currentMissionIndex = 0;
            aiHintUsesLeft = AI_HINT_USES;
            nextPieceData = determineNextPiece();
            loadMission(currentMissionIndex); // Load mission 0

            if (isDemoMode) {
                console.log("Starting Demo Mode...");
                showMessage("Demo Mode Running...", 0); // Persistent message
                controls.enabled = false; // Disable camera controls during demo
                // Start the automated demo steps
                runDemoStep();
            } else {
                console.log("Gameplay Started!");
                controls.enabled = true; // Ensure camera controls are enabled
            }
        }

        // Called when welcome screen button is clicked
        function showMainMenu() {
             const name = playerNameInput.value.trim();
             if (name) { playerName = name; console.log(`Player Name: ${playerName}`); }
             else { console.log("No name entered, using default."); }

             welcomeScreen.style.display = 'none';
             mainMenuScreen.style.display = 'flex'; // Show the main menu
        }


        async function setupAudio() { /* ... same as before ... */ try { synthMove = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }, volume: -20 }).toDestination(); synthRotate = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.1 }, volume: -18 }).toDestination(); synthLock = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 3, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }, volume: -12 }).toDestination(); synthCorrectLock = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -15 }).toDestination(); synthMissionComplete = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.4 }, volume: -10 }).toDestination(); console.log("Audio synths created."); } catch (error) { console.error("Error creating Tone.js synths:", error); audioReady = false; } }
        function initPreviewRenderer() { /* ... same as before ... */ previewScene=new THREE.Scene(); previewScene.background=null; const a=PREVIEW_CANVAS_SIZE/PREVIEW_CANVAS_SIZE; const fS=4*CUBE_SIZE; previewCamera=new THREE.OrthographicCamera(fS*a/-2,fS*a/2,fS/2,fS/-2,0.1,100); previewCamera.position.set(0,0,5); previewCamera.lookAt(0,0,0); previewRenderer=new THREE.WebGLRenderer({canvas:previewCanvas,antialias:true,alpha:true}); previewRenderer.setSize(PREVIEW_CANVAS_SIZE,PREVIEW_CANVAS_SIZE); previewRenderer.setPixelRatio(window.devicePixelRatio); previewRenderer.toneMapping=THREE.ACESFilmicToneMapping; previewRenderer.toneMappingExposure=1.0; const pA=new THREE.AmbientLight(0xffffff,1.0); previewScene.add(pA); const pL=new THREE.DirectionalLight(0xffffff,1.5); pL.position.set(1,2,3); previewScene.add(pL); }
        function loadTextures() { /* ... same as before ... */ const gTU=`https://placehold.co/64x64/cccccc/999999.png?text=+`; groundTexture=textureLoader.load(gTU,(t)=>{t.wrapS=THREE.RepeatWrapping; t.wrapT=THREE.RepeatWrapping; t.repeat.set(BOARD_WIDTH,BOARD_DEPTH); console.log("GT loaded."); groundPlane=scene.getObjectByName("groundPlane"); if(groundPlane){groundPlane.material.map=t; groundPlane.material.needsUpdate=true;}},undefined,(e)=>{console.error('Error loading GT:',e);}); }
        function initBoard() { /* ... same as before ... */ board=Array(BOARD_WIDTH).fill(null).map(()=>Array(BOARD_HEIGHT).fill(null).map(()=>Array(BOARD_DEPTH).fill(0))); }
        function createBoardVisuals() { /* ... same as before ... */ const gH=new THREE.GridHelper(Math.max(BOARD_WIDTH,BOARD_DEPTH),Math.max(BOARD_WIDTH,BOARD_DEPTH),0x888888,0x444444); gH.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2+0.01,BOARD_DEPTH/2-CUBE_SIZE/2); scene.add(gH); const gG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_DEPTH*CUBE_SIZE); const gM=new THREE.MeshStandardMaterial({color:0xaaaaaa,map:groundTexture,side:THREE.DoubleSide,roughness:0.8,metalness:0.2}); groundPlane=new THREE.Mesh(gG,gM); groundPlane.name="groundPlane"; groundPlane.rotation.x=-Math.PI/2; groundPlane.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); groundPlane.receiveShadow=true; scene.add(groundPlane); const wM=new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.05,side:THREE.DoubleSide}); const bWG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const bW=new THREE.Mesh(bWG,wM); bW.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,-CUBE_SIZE/2); scene.add(bW); const lWG=new THREE.PlaneGeometry(BOARD_DEPTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const lW=new THREE.Mesh(lWG,wM); lW.position.set(-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); lW.rotation.y=Math.PI/2; scene.add(lW); const rW=lW.clone(); rW.position.x=BOARD_WIDTH-CUBE_SIZE/2; scene.add(rW); }

        // --- Starfield ---
        function createStarfield(){ if(starfield)removeStarfield(); const v=[]; for(let i=0;i<STARFIELD_COUNT;i++){ const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const r=STARFIELD_RADIUS*Math.cbrt(Math.random()); const x=r*Math.sin(ph)*Math.cos(th); const y=r*Math.sin(ph)*Math.sin(th); const z=r*Math.cos(ph); v.push(x,y,z); } const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); const m=new THREE.PointsMaterial({color:0xffffff,size:0.15,sizeAttenuation:true,transparent:true,opacity:0.8}); starfield=new THREE.Points(g,m); starfield.name="starfield"; scene.add(starfield); console.log("Starfield created."); }
        function removeStarfield(){ if(starfield){ scene.remove(starfield); starfield.geometry.dispose(); starfield.material.dispose(); starfield=null; console.log("Starfield removed."); } }

        // --- Theme Application ---
        function applyTheme(themeName) { /* ... same as before ... */ const theme=themes[themeName]; if(!theme){console.warn(`Theme "${themeName}" not found.`); return;} console.log(`Applying theme: ${themeName}`); currentTheme=themeName; removeStarfield(); if(scene.background&&scene.background.isTexture){scene.background=null;} if(theme.starfield){scene.background=theme.background; createStarfield();}else if(theme.skybox&&theme.skybox.length===6){scene.background=theme.background; cubeTextureLoader.load(theme.skybox,(t)=>{scene.background=t; console.log(`${themeName} skybox loaded.`);},undefined,(e)=>{console.error(`Skybox error ${themeName}:`,e); scene.background=theme.background;});}else{scene.background=theme.background;} if(theme.fog){if(!scene.fog){scene.fog=new THREE.Fog(theme.fog.color,theme.fog.near,theme.fog.far);}else{scene.fog.color.set(theme.fog.color); scene.fog.near=theme.fog.near; scene.fog.far=theme.fog.far;}}else{scene.fog=null;} if(theme.lights){hemisphereLight.color.setHex(theme.lights.hemiSky); hemisphereLight.groundColor.setHex(theme.lights.hemiGround); hemisphereLight.intensity=theme.lights.hemiIntensity; ambientLight.color.setHex(theme.lights.ambient); ambientLight.intensity=theme.lights.ambientIntensity; directionalLight.color.setHex(theme.lights.dir); directionalLight.intensity=theme.lights.dirIntensity; directionalLight.position.y=theme.lights.dirY; if(hemiIntensitySlider)hemiIntensitySlider.value=theme.lights.hemiIntensity; if(hemiIntensityValueSpan)hemiIntensityValueSpan.textContent=theme.lights.hemiIntensity.toFixed(1); if(ambientIntensitySlider)ambientIntensitySlider.value=theme.lights.ambientIntensity; if(ambientIntensityValueSpan)ambientIntensityValueSpan.textContent=theme.lights.ambientIntensity.toFixed(1); if(dirIntensitySlider)dirIntensitySlider.value=theme.lights.dirIntensity; if(dirIntensityValueSpan)dirIntensityValueSpan.textContent=theme.lights.dirIntensity.toFixed(1); if(dirYSlider)dirYSlider.value=theme.lights.dirY; if(dirYValueSpan)dirYValueSpan.textContent=theme.lights.dirY.toFixed(0);} if(groundPlane&&groundPlane.material){groundPlane.material.color.setHex(theme.groundColor); groundPlane.material.needsUpdate=true;} const rootStyle=document.documentElement.style; if(theme.ui){rootStyle.setProperty('--panel-bg',theme.ui.panelBg); rootStyle.setProperty('--panel-border',theme.ui.panelBorder); rootStyle.setProperty('--text-color',theme.ui.textColor); rootStyle.setProperty('--text-color-muted',theme.ui.textColorMuted); rootStyle.setProperty('--text-color-heading',theme.ui.textColorHeading); rootStyle.setProperty('--accent-color',theme.ui.accent); rootStyle.setProperty('--button-bg',theme.ui.buttonBg||'#4b5563'); rootStyle.setProperty('--button-border',theme.ui.buttonBorder||'#6b7280'); rootStyle.setProperty('--button-hover-bg',theme.ui.buttonHoverBg||'#374151');} if(themeButtons)themeButtons.forEach(button=>{button.classList.toggle('active',button.dataset.theme===themeName);}); }


        // --- Mission Handling --- (Unchanged)
        function loadMission(mI, isR=false){ if(!gameStarted) return; if(fallInterval)clearInterval(fallInterval); fallInterval=null; if(!isR&&mI>=missions.length){showMessage(`All Missions Complete! Final Score: ${totalScore}`);gameOver(true);return;} if(mI>=missions.length){mI=missions.length-1;} const m=missions[mI]; console.log(`Loading Mission: ${m.name}`); clearBoard(); clearGhostBlocks(); if(currentPiece){scene.remove(currentPiece.mesh);currentPiece=null;} placedTargetBlocks=0; targetBlockCount=m.b.length; displayBlueprint(m.b); document.getElementById('mission-name').textContent=m.name; isGameOver=false; isPaused=false; pauseButton.textContent='Pause'; hideMessage(); missionStartTime=clock.getElapsedTime(); updateUI(); if(!isR||!nextPieceData){nextPieceData=determineNextPiece();} updatePreview(nextPieceData); spawnPiece(); if(currentPiece&&!isGameOver&&!isDemoMode){currentFallSpeed=FALL_SPEED_NORMAL;startGameLoop();}else if(isGameOver){console.log("GO on load.");} }
        function displayBlueprint(b){ /* ... same as before ... */ const gm=new THREE.MeshStandardMaterial({color:0xaaaaaa,transparent:true,opacity:0.25,roughness:0.9}); const gg=new THREE.BoxGeometry(CUBE_SIZE*0.95,CUBE_SIZE*0.95,CUBE_SIZE*0.95); b.forEach(c=>{ if(c.x<0||c.x>=BOARD_WIDTH||c.y<0||c.y>=BOARD_HEIGHT||c.z<0||c.z>=BOARD_DEPTH){console.warn("BP coord out:",c);return;} const gc=new THREE.Mesh(gg,gm.clone()); gc.position.set(c.x*CUBE_SIZE,c.y*CUBE_SIZE,c.z*CUBE_SIZE); gc.userData.isGhost=true; gc.userData.originalPosition={x:c.x,y:c.y,z:c.z}; gc.userData.baseOpacity = gm.opacity; scene.add(gc); ghostBlocks.push(gc);}); targetBlockCount=ghostBlocks.length; updateUI();}
        function clearGhostBlocks() { stopBlinkingHint(); ghostBlocks.forEach(g => { scene.remove(g); }); ghostBlocks = []; }
        function checkMissionCompletion(){
            if(isGameOver || !gameStarted)return false;
            if(placedTargetBlocks>=targetBlockCount&&targetBlockCount>0){
                stopBlinkingHint();
                const mN=missions[currentMissionIndex].name;

                if (isDemoMode) {
                    // End demo after completing the mission
                    showMessage(`Demo Complete!`, 2000);
                    setTimeout(goToMainMenu, 2100); // Return to menu after delay
                    return true; // Signal completion handled
                } else {
                    // Normal game completion logic
                    let mCB=POINTS_MISSION_COMPLETE; const tT=clock.getElapsedTime()-missionStartTime; const tBR=Math.max(0,1.0-(tT/MAX_TIME_ALLOWED_PER_MISSION)); let tB=Math.round(MAX_TIME_BONUS*tBR); totalScore+=mCB; totalScore+=tB; updateUI(); showMessage(`Mission ${mN} Complete!\nScore +${mCB} +${tB} (Time)`,3500); const cP=new THREE.Vector3(BOARD_WIDTH/2*CUBE_SIZE,0,BOARD_DEPTH/2*CUBE_SIZE); createParticleEffect(cP,0xffd700,150,1.5); currentMissionIndex++; if(fallInterval)clearInterval(fallInterval); fallInterval=null;
                    if (audioReady && synthMissionComplete) { const now = Tone.now(); synthMissionComplete.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now); synthMissionComplete.triggerAttackRelease("E5", "4n", now + Tone.Time("4n").toSeconds()); }
                    setTimeout(()=>{loadMission(currentMissionIndex);},3600);
                    return true;
                }
            }
            return false;
        }

        // --- Game Loop & Piece Logic --- (Unchanged)
        function startGameLoop(){ if(isPaused||isGameOver||!gameStarted||isDemoMode)return; /* Don't run interval in demo */ if(fallInterval)clearInterval(fallInterval); fallInterval=setInterval(()=>{if(!isPaused&&!isGameOver&&currentPiece&&gameStarted&&!isDemoMode){movePiece(0,-1,0);}},currentFallSpeed); console.log("Timer start/reset:",currentFallSpeed); }
        function stopGameLoop(){ if(fallInterval){clearInterval(fallInterval); fallInterval=null; console.log("Timer stop.");} if (demoTimeoutId) { clearTimeout(demoTimeoutId); demoTimeoutId = null; console.log("Demo step timer stopped.");} } // Also stop demo timer
        function resetFallTimer(){ if(!isPaused&&!isGameOver&&gameStarted&&!isDemoMode){startGameLoop();} } // Don't run in demo
        function determineNextPiece(){ const k=TETROMINO_KEYS[Math.floor(Math.random()*TETROMINO_KEYS.length)]; const d=TETROMINOES[k]; return {type:k, color:d.c, shape:JSON.parse(JSON.stringify(d.s))}; }
        function spawnPiece(){ if(isGameOver||isPaused||!gameStarted)return; if(!nextPieceData){console.warn("nextPD null."); nextPieceData=determineNextPiece();} const cPD=nextPieceData; nextPieceData=determineNextPiece(); updatePreview(nextPieceData); const sX=Math.floor(BOARD_WIDTH/2); const sY=BOARD_HEIGHT-1; const sZ=Math.floor(BOARD_DEPTH/2); const pG=new THREE.Group(); const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:cPD.color,metalness:0.3,roughness:0.5}); cPD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); c.castShadow=true; c.receiveShadow=false; pG.add(c); }); currentPiece={mesh:pG,shape:cPD.shape,x:sX,y:sY,z:sZ,rotationY:0}; currentPiece.mesh.position.set(sX*CUBE_SIZE,sY*CUBE_SIZE,sZ*CUBE_SIZE); if(!isValidMove(currentPiece.x,currentPiece.y,currentPiece.z,currentPiece.shape)){console.log("GO on spawn!"); gameOver(); currentPiece=null; if(nextPieceData)updatePreview(nextPieceData); return;} scene.add(currentPiece.mesh); console.log("Spawned:",cPD.type,"Next:",nextPieceData.type); updateUI(); }
        function movePiece(dx,dy,dz, userInitiated = false){ if(!currentPiece||isPaused||isGameOver||!gameStarted)return; stopBlinkingHint(); const nX=currentPiece.x+dx; const nY=currentPiece.y+dy; const nZ=currentPiece.z+dz; if(isValidMove(nX,nY,nZ,currentPiece.shape)){ currentPiece.x=nX; currentPiece.y=nY; currentPiece.z=nZ; currentPiece.mesh.position.set(currentPiece.x*CUBE_SIZE,currentPiece.y*CUBE_SIZE,currentPiece.z*CUBE_SIZE); if (userInitiated && audioReady && synthMove) { synthMove.triggerAttackRelease("C5", "32n", Tone.now()); } } else if(dy<0){ lockPiece(); if(!isGameOver && !isDemoMode){ spawnPiece(); if(currentFallSpeed!==FALL_SPEED_NORMAL){ currentFallSpeed=FALL_SPEED_NORMAL; resetFallTimer(); } } else if (!isGameOver && isDemoMode) { runDemoStep(); /* Trigger next demo step after lock */ } } }
        function rotatePieceY(){ if(!currentPiece||isPaused||isGameOver||!gameStarted)return; stopBlinkingHint(); const ax=new THREE.Vector3(0,1,0); const ang=Math.PI/2; const qu=new THREE.Quaternion().setFromAxisAngle(ax,ang); const rs=currentPiece.shape.map(o=>{ const v=new THREE.Vector3(o[0],o[1],o[2]).applyQuaternion(qu); return [Math.round(v.x),Math.round(v.y),Math.round(v.z)]; }); if(isValidMove(currentPiece.x,currentPiece.y,currentPiece.z,rs)){ currentPiece.mesh.applyQuaternion(qu); currentPiece.shape=rs; currentPiece.rotationY=(currentPiece.rotationY+ang)%(2*Math.PI); if (audioReady && synthRotate) { synthRotate.triggerAttackRelease("E5", "16n", Tone.now()); } console.log("Rotated"); } else { console.log("Rot blocked"); } }
        function isValidMove(bX,bY,bZ,sh){ /* Allow check even if game not started for AI/Demo */ for(const o of sh){ const wX=bX+o[0]; const wY=bY+o[1]; const wZ=bZ+o[2]; if(wX<0||wX>=BOARD_WIDTH||wY<0||wZ<0||wZ>=BOARD_DEPTH)return false; if(wY>=BOARD_HEIGHT)continue; if(board[wX][wY][wZ]!==0)return false; } return true; }
        function lockPiece(){ if(!currentPiece||isGameOver||!gameStarted)return; stopBlinkingHint(); console.log("Locking:",currentPiece.x,currentPiece.y,currentPiece.z); let mPM=false; const pM=currentPiece.mesh.children[0].material; let sGTL=0; currentPiece.shape.forEach(o=>{ const wX=currentPiece.x+o[0]; const wY=currentPiece.y+o[1]; const wZ=currentPiece.z+o[2]; if(wX>=0&&wX<BOARD_WIDTH&&wY>=0&&wY<BOARD_HEIGHT&&wZ>=0&&wZ<BOARD_DEPTH){ const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=pM.clone(); const lC=new THREE.Mesh(geo,mat); lC.position.set(wX*CUBE_SIZE,wY*CUBE_SIZE,wZ*CUBE_SIZE); lC.castShadow=true; lC.receiveShadow=true; lockedBlocksGroup.add(lC); board[wX][wY][wZ]=1; if (!isDemoMode) totalScore+=POINTS_PER_CUBE; sGTL+=POINTS_PER_CUBE; const fGI=ghostBlocks.findIndex(g=>g.visible&&g.userData.originalPosition.x===wX&&g.userData.originalPosition.y===wY&&g.userData.originalPosition.z===wZ); if(fGI!==-1){ ghostBlocks[fGI].visible=false; placedTargetBlocks++; mPM=true; console.log("BP filled!"); if (!isDemoMode) totalScore+=POINTS_PER_CORRECT_CUBE_BONUS; sGTL+=POINTS_PER_CORRECT_CUBE_BONUS; const pP=lC.position.clone(); createParticleEffect(pP,mat.color); const oE=mat.emissive.getHex(); mat.emissive.setHex(0xffffff); mat.needsUpdate=true; setTimeout(()=>{if(lC.parent){mat.emissive.setHex(oE); mat.needsUpdate=true;}},LOCK_FLASH_DURATION); } }else{ console.warn("Lock out:",wX,wY,wZ); if(wY>=BOARD_HEIGHT){console.log("Lock above - GO."); if(currentPiece&&currentPiece.mesh.parent)scene.remove(currentPiece.mesh); currentPiece=null; gameOver(); return;} } }); if(currentPiece&&currentPiece.mesh.parent){scene.remove(currentPiece.mesh);} currentPiece=null; console.log(`Score gain lock: ${sGTL}`); if (audioReady && !isDemoMode) { if (mPM && synthCorrectLock) { synthCorrectLock.triggerAttackRelease("G5", "16n", Tone.now()); } if (synthLock) { synthLock.triggerAttackRelease("C2", "8n", Tone.now() + 0.01); } } updateUI(); if(!isGameOver&&mPM){checkMissionCompletion();} }
        function clearBoard(){ initBoard(); while(lockedBlocksGroup.children.length>0){ const o=lockedBlocksGroup.children[0]; if(o.geometry)o.geometry.dispose(); if(o.material){if(Array.isArray(o.material))o.material.forEach(m=>m.dispose()); else o.material.dispose();} lockedBlocksGroup.remove(o); } activeParticles.forEach(p=>scene.remove(p.mesh)); activeParticles=[]; removeStarfield(); }
        function gameOver(isC=false){ console.log("GO. All complete:",isC); isGameOver=true; stopGameLoop(); stopBlinkingHint(); if(!isC)showMessage(`Game Over! Final Score: ${totalScore}`); updateUI(); }

        // --- UI Functions ---
        function updateUI(){ if(!gameStarted && !isGameOver && !isDemoMode) return; // Don't update UI before start, but update on Game Over or during Demo
             if(scoreDisplay) scoreDisplay.textContent = isDemoMode ? "DEMO" : totalScore; // Show DEMO instead of score
             if(document.getElementById('blocks-placed')) document.getElementById('blocks-placed').textContent=placedTargetBlocks;
             if(document.getElementById('blocks-target')) document.getElementById('blocks-target').textContent=targetBlockCount;
             if (aiHelpButton) { aiHelpButton.textContent = `AI Hint (${aiHintUsesLeft})`; aiHelpButton.disabled = (isDemoMode || aiHintUsesLeft <= 0 || isPaused || isGameOver || !nextPieceData || placedTargetBlocks < AI_HINT_ACTIVATE_THRESHOLD || !gameStarted); } // Disable in demo
             if(pauseButton) pauseButton.disabled = isGameOver || !gameStarted || isDemoMode; // Disable in demo
             if(restartButton) restartButton.disabled = !gameStarted; // Disable restart if game not started (on welcome/menu)
        }
        function showMessage(t,d=3000){ messageBox.textContent=t; messageBox.style.display='block'; if(d>0){setTimeout(()=>{if(messageBox.textContent===t)hideMessage();},d);} }
        function hideMessage(){ messageBox.style.display='none'; }
        function togglePause(){ if(isGameOver||!gameStarted||isDemoMode)return; /* No pause in demo */ isPaused=!isPaused; console.log("Paused:",isPaused); if(isPaused){ stopGameLoop(); stopBlinkingHint(); showMessage("Paused",0); pauseButton.textContent='Resume'; }else{ hideMessage(); pauseButton.textContent='Pause'; if(currentPiece)startGameLoop(); else{ console.log("Resume no piece, spawn."); spawnPiece(); if(currentPiece&&!isGameOver)startGameLoop(); } } updateUI(); }

        // Renamed from restartMission
        function goToMainMenu() {
            console.log("Returning to main menu...");
            stopGameLoop(); // Stops interval and demo timeout
            stopBlinkingHint();
            isGameOver = false; isPaused = false; gameStarted = false; isDemoMode = false; // Reset all flags
            hideMessage();

            clearBoard(); // Resets board array, clears locked blocks, removes starfield
            if (currentPiece) { scene.remove(currentPiece.mesh); currentPiece = null; }
            ghostBlocks = []; updatePreview(null);
            aiHintUsesLeft = AI_HINT_USES; // Reset hints

            uiOverlay.style.display = 'none'; // Hide game UI
            mainMenuScreen.style.display = 'flex'; // Show main menu
            welcomeScreen.style.display = 'none';
            helpScreen.style.display = 'none'; // Ensure help screen is hidden too
            controls.enabled = true; // Ensure camera controls re-enabled
        }

        // --- Preview Update --- (Unchanged)
        function updatePreview(pD){ if(!previewScene)return; if(previewPieceMesh){previewScene.remove(previewPieceMesh);} if(!pD)return; const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:pD.color,metalness:0.3,roughness:0.5}); previewPieceMesh=new THREE.Group(); pD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); previewPieceMesh.add(c); }); const box=new THREE.Box3().setFromObject(previewPieceMesh); const center=box.getCenter(new THREE.Vector3()); previewPieceMesh.position.sub(center); previewScene.add(previewPieceMesh); console.log("Preview:",pD.type); }

        // --- Particle System --- (Unchanged)
        function createParticleEffect(p,c=0xffffff,co=PARTICLE_COUNT,l=PARTICLE_LIFESPAN){ const pg=new THREE.BufferGeometry(); const v=[]; const ve=[]; const st=[]; for(let i=0;i<co;i++){ v.push(0,0,0); const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const sp=1+Math.random()*3; ve.push(Math.sin(ph)*Math.cos(th)*sp,Math.cos(ph)*sp,Math.sin(ph)*Math.sin(th)*sp); st.push(clock.getElapsedTime()); } pg.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); pg.setAttribute('velocity',new THREE.Float32BufferAttribute(ve,3)); pg.setAttribute('startTime',new THREE.Float32BufferAttribute(st,1)); const pm=new THREE.PointsMaterial({color:c,size:0.1,transparent:true,opacity:0.8,sizeAttenuation:true,depthWrite:false,blending:THREE.AdditiveBlending}); const pt=new THREE.Points(pg,pm); pt.position.copy(p); scene.add(pt); activeParticles.push({mesh:pt,geometry:pg,material:pm,startTime:clock.getElapsedTime(),lifespan:l}); }
        function updateParticles(dt){ const ct=clock.getElapsedTime(); for(let i=activeParticles.length-1;i>=0;i--){ const s=activeParticles[i]; const et=ct-s.startTime; if(et>s.lifespan){ scene.remove(s.mesh); s.geometry.dispose(); s.material.dispose(); activeParticles.splice(i,1); continue; } const ps=s.geometry.attributes.position; const vs=s.geometry.attributes.velocity; for(let j=0;j<ps.count;j++){ const ix=j*3; const pST=s.geometry.attributes.startTime.array[j]; const pET=ct-pST; ps.array[ix]+=vs.array[ix]*dt; ps.array[ix+1]+=vs.array[ix+1]*dt-0.5*9.8*pET*dt; ps.array[ix+2]+=vs.array[ix+2]*dt; } ps.needsUpdate=true; s.material.opacity=0.8*(1.0-(et/s.lifespan)); s.material.needsUpdate=true; } }

        // --- AI Hint / Demo Logic ---
        // Renamed: Finds best placement for a given piece shape
        function findBestPlacementForPiece(pieceShape) {
            if (!pieceShape || !ghostBlocks.length) return null;

            let bestScore = -1; let bestPlacement = null;
            const visibleGhostCoordsMap=new Map(); ghostBlocks.forEach((g,index)=>{if(g.visible){const pos=g.userData.originalPosition; const key=`${pos.x},${pos.y},${pos.z}`; visibleGhostCoordsMap.set(key,{mesh:g,index:index});}});
            // If no ghosts visible, cannot find a placement that fills ghosts
            if (visibleGhostCoordsMap.size === 0 && !isDemoMode) return null; // Hint needs ghosts
             // For Demo mode, if no ghosts are left, it might mean the mission is done or nearly done.
             // Let's allow finding *any* valid spot in demo if no ghosts match.
             const needsGhost = !isDemoMode || visibleGhostCoordsMap.size > 0;


            const yAxis=new THREE.Vector3(0,1,0);
            for(let rot=0;rot<4;rot++){
                const angle=rot*Math.PI/2; const quaternion=new THREE.Quaternion().setFromAxisAngle(yAxis,angle);
                const rotatedShape=pieceShape.map(offset=>{const vec=new THREE.Vector3(offset[0],offset[1],offset[2]).applyQuaternion(quaternion); return [Math.round(vec.x),Math.round(vec.y),Math.round(vec.z)];});
                for(let x=0;x<BOARD_WIDTH;x++){
                    for(let z=0;z<BOARD_DEPTH;z++){
                        let finalY=BOARD_HEIGHT; while(finalY>=0){finalY--; if(!isValidMove(x,finalY,z,rotatedShape)){finalY++; break;}}
                        if(finalY>=BOARD_HEIGHT||!isValidMove(x,finalY,z,rotatedShape))continue;
                        let filledGhostsCount=0; let filledGhostMeshes=[];
                        rotatedShape.forEach(offset=>{const wX=x+offset[0]; const wY=finalY+offset[1]; const wZ=z+offset[2]; const key=`${wX},${wY},${wZ}`; if(visibleGhostCoordsMap.has(key)){filledGhostsCount++; filledGhostMeshes.push(visibleGhostCoordsMap.get(key).mesh);}});

                        // Check if placement is suitable
                        // Hint requires filling ghosts. Demo prefers filling ghosts but accepts any valid spot if none fill ghosts.
                        if ( (needsGhost && filledGhostsCount > 0) || (!needsGhost && filledGhostsCount === 0) ) {
                             const placementScore=filledGhostsCount*1000-finalY; // Score still prioritizes filling ghosts
                             if(placementScore>bestScore){bestScore=placementScore; bestPlacement={x,y:finalY,z,rotation:angle,shape:rotatedShape,filledMeshes:filledGhostMeshes};}
                        }
                    }
                }
            }
            // If in Demo and still no spot found (e.g., board full), return null
            if (isDemoMode && !bestPlacement && needsGhost) {
                 console.log("Demo/Hint: No ghost-filling spot found.");
                 // Optionally, could add logic here to find *any* valid spot for demo,
                 // but for now, returning null is okay, demo step will handle it.
            }

            return bestPlacement;
        }

        function startBlinkingHint(ghostMeshesToBlink) { stopBlinkingHint(); if (!ghostMeshesToBlink || ghostMeshesToBlink.length === 0) return; isBlinkingHint = true; blinkingGhostsInfo = ghostMeshesToBlink.map(mesh => ({ mesh: mesh, originalOpacity: mesh.userData.baseOpacity || 0.25 })); let blinkOn = false; blinkIntervalId = setInterval(() => { blinkOn = !blinkOn; blinkingGhostsInfo.forEach(info => { if (info.mesh && info.mesh.material) { info.mesh.material.opacity = blinkOn ? 0.8 : info.originalOpacity * 0.5; info.mesh.material.emissive.setHex(blinkOn ? 0xffffff : 0x000000); info.mesh.material.needsUpdate = true; } }); }, HINT_BLINK_INTERVAL); setTimeout(stopBlinkingHint, HINT_BLINK_DURATION); }
        function stopBlinkingHint() { if (blinkIntervalId) { clearInterval(blinkIntervalId); blinkIntervalId = null; } blinkingGhostsInfo.forEach(info => { if (info.mesh && info.mesh.material) { info.mesh.material.opacity = info.originalOpacity; info.mesh.material.emissive.setHex(0x000000); info.mesh.material.needsUpdate = true; } }); blinkingGhostsInfo = []; isBlinkingHint = false; }
        function useAiHint() { if (isGameOver || isPaused || !gameStarted || !nextPieceData || aiHintUsesLeft <= 0 || placedTargetBlocks < AI_HINT_ACTIVATE_THRESHOLD) { console.log("AI Hint conditions not met."); updateUI(); return; } console.log("Attempting AI Hint..."); const placement = findBestPlacementForPiece(nextPieceData.shape); /* Analyze NEXT piece */ if (placement && placement.filledMeshes.length > 0) { aiHintUsesLeft--; totalScore -= AI_HINT_COST; console.log(`AI Hint used. Uses left: ${aiHintUsesLeft}. Score: ${totalScore}`); startBlinkingHint(placement.filledMeshes); showMessage("Hint Activated!", HINT_BLINK_DURATION); } else { console.log("AI Hint couldn't find a useful placement for the next piece."); showMessage("AI Hint: No spot found!", 1500); } updateUI(); }

        // --- Demo Mode Logic ---
        function runDemoStep() {
            if (!isDemoMode || isGameOver || !currentPiece) { if (isDemoMode) goToMainMenu(); return; } // Stop demo if conditions change

            console.log("Running Demo Step...");
            const placement = findBestPlacementForPiece(currentPiece.shape); // Find placement for CURRENT piece

            if (placement) {
                 // Instantly move and lock
                 currentPiece.mesh.rotation.set(0, placement.rotation, 0);
                 currentPiece.mesh.position.set(placement.x * CUBE_SIZE, placement.y * CUBE_SIZE, placement.z * CUBE_SIZE);
                 currentPiece.x = placement.x; currentPiece.y = placement.y; currentPiece.z = placement.z;
                 currentPiece.shape = placement.shape; currentPiece.rotationY = placement.rotation;

                 lockPiece(); // Lock it (handles score=0 in demo, checks completion which might end demo)

                 // If game didn't end during lock/completion check, schedule next step
                 if (!isGameOver && isDemoMode) { // Check isDemoMode again in case completion ended it
                    spawnPiece(); // Spawn next piece immediately for demo logic
                    if (currentPiece) { // Ensure a piece actually spawned
                        demoTimeoutId = setTimeout(runDemoStep, DEMO_STEP_DELAY);
                    } else if (!isGameOver) {
                         console.log("Demo: No more pieces to spawn or game over after spawn.");
                         goToMainMenu(); // End demo if no piece spawns
                    }
                 }
            } else {
                 // No valid placement found for the current piece. Skip it.
                 console.log("Demo: Could not find placement for current piece, skipping.");
                 if (currentPiece && currentPiece.mesh.parent) {
                     scene.remove(currentPiece.mesh); // Remove the piece visually
                 }
                 currentPiece = null; // Clear the piece reference

                 // Spawn the next piece and schedule the next step
                 spawnPiece();
                 if (currentPiece && !isGameOver) {
                     demoTimeoutId = setTimeout(runDemoStep, DEMO_STEP_DELAY / 2); // Faster skip
                 } else {
                     console.log("Demo: Ending after skip because no piece spawned or game over.");
                     goToMainMenu();
                 }
            }
        }


        // --- Event Handlers --- (WASD Controls, disable during demo)
        function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function onKeyDown(e){
            // Allow R key always to return to menu
            if(e.key==='r'||e.key==='R'){ goToMainMenu(); return; }
            // Other controls only active if game started and not in demo
            if(!gameStarted || isDemoMode) return;

            if(e.key==='p'||e.key==='P'){togglePause();return;}
            if(e.key==='h'||e.key==='H'){useAiHint(); return;}

            if(isGameOver||isPaused||!currentPiece)return;

            if (['a', 'A', 'd', 'D', 'w', 'W', 's', 'S', ' ', 'ArrowDown'].includes(e.key)) {
                stopBlinkingHint();
            }

            switch(e.key){
                case 'a': case 'A': movePiece(-1,0,0, true); break;
                case 'd': case 'D': movePiece(1,0,0, true); break;
                case 'w': case 'W': movePiece(0,0,-1, true); break;
                case 's': case 'S': movePiece(0,0,1, true); break;
                case ' ': rotatePieceY(); break;
                case 'ArrowDown': if(currentFallSpeed!==FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_FAST;resetFallTimer();}movePiece(0,-1,0);break;
            }
        }
        function onKeyUp(e){ if(!gameStarted || isGameOver||isPaused||isDemoMode)return; if(e.key==='ArrowDown'){if(currentFallSpeed===FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_NORMAL;resetFallTimer();}} }

        // --- Animation Loop --- (Unchanged)
        function animate() { requestAnimationFrame(animate); const dt=clock.getDelta(); controls.update(); if(gameStarted && !isPaused && !isDemoMode){updateParticles(dt);} /* Only update particles in normal play */ renderer.render(scene,camera); if(previewRenderer&&previewScene&&previewCamera){ if(previewPieceMesh && gameStarted && !isPaused){previewPieceMesh.rotation.y+=0.01;} previewRenderer.render(previewScene,previewCamera); } }

        // --- Start the game ---
        init(); // Call init, game waits for user action via welcome/menu screens

    </script>
</body>
</html>
