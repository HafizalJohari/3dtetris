<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tetris Builder</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp,container-queries"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        :root { /* Define CSS Variables for UI Theming */
            --panel-bg: rgba(50, 50, 50, 0.85);
            --panel-border: rgba(100, 116, 139, 0.7); /* slate-500 */
            --text-color: #e5e7eb; /* gray-200 */
            --text-color-muted: #9ca3af; /* gray-400 */
            --text-color-heading: #f3f4f6; /* gray-100 */
            --button-bg: #4b5563; /* gray-600 */
            --button-border: #6b7280; /* gray-500 */
            --button-hover-bg: #374151; /* gray-700 */
            --button-active-bg: #1f2937; /* gray-800 */
            --accent-color: #3b82f6; /* blue-500 */
            --font-main: 'Inter', sans-serif; /* Keep Inter for body */
            --font-display: 'Press Start 2P', cursive; /* Use block font for UI */
        }

        body { margin: 0; overflow: hidden; font-family: var(--font-main); background-color: #111827; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas { display: block; }

        /* --- Overlays --- */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(17, 24, 39, 0.95); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-color-heading); text-align: center; padding: 1rem; font-family: var(--font-display); overflow: hidden; /* Prevent scrollbars on overlay itself */ }
        #welcome-screen { /* Starts visible */ }
        #main-menu-screen { display: none; /* Hidden initially */ }
        #help-screen { display: none; /* Hidden initially */ justify-content: flex-start; padding-top: 3rem; overflow-y: auto; /* Allow scroll only on help */ }

        /* Welcome Screen Specifics (New Style) */
        #welcome-screen h1 {
            font-size: 2.25rem; /* text-4xl */
            font-weight: normal; /* Use font's default weight */
            margin-bottom: 1rem; color: #fff;
            /* Apply glow effect */
            text-shadow: 0 0 5px #00f0ff, 0 0 10px #00f0ff, 0 0 15px #00f0ff;
        }
        #welcome-screen p {
             font-size: 0.8rem; /* Adjusted size */
             line-height: 1.5; color: #60a5fa; /* text-blue-400 */
             margin-bottom: 2.5rem; /* Increased margin */
             /* Apply floating animation */
             animation: float 4s ease-in-out infinite;
        }
        #player-name {
            padding: 0.75rem 1rem; font-size: 0.8rem; /* Adjusted size */
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid var(--accent-color); /* Use accent color for border */
            background-color: rgba(17, 24, 39, 0.8); /* bg-gray-900 slightly transparent */
            color: var(--text-color-heading); margin-bottom: 1.5rem;
            width: 100%; max-width: 300px; text-align: center;
            font-family: var(--font-main); /* Use standard font for input */
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5); /* Subtle glow matching accent */
        }
        #player-name::placeholder { color: var(--text-color-muted); }
        #start-game-button {
            padding: 0.75rem 2rem; font-size: 0.9rem; /* Adjusted size */
            font-weight: normal; border-radius: 0.5rem;
            background-color: var(--accent-color); color: white; border: none;
            cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease;
            font-family: var(--font-display);
        }
         #start-game-button:hover { background-color: #2563eb; /* blue-600 */ }
         #start-game-button:active { transform: scale(0.98); }
         /* Background Texture Div */
         #welcome-bg-texture {
             position: absolute; width: 100%; height: 100%;
             top: 0; left: 0; pointer-events: none;
             opacity: 0.1; z-index: -1; /* Behind content */
             background-image: url('https://www.transparenttextures.com/patterns/graphy.png');
             background-repeat: repeat;
         }

        /* Main Menu Specifics */
        #main-menu-screen h1 { font-size: 1.8rem; line-height: 1.4; font-weight: normal; margin-bottom: 2.5rem; color: #fff; }
        .menu-button { padding: 0.6rem 1.5rem; font-size: 1rem; font-weight: normal; border-radius: 0.5rem; background-color: var(--button-bg); color: var(--text-color-heading); border: 1px solid var(--button-border); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-family: var(--font-display); margin-bottom: 1rem; width: 250px; display: block; margin-left: auto; margin-right: auto; }
        .menu-button:hover { background-color: var(--button-hover-bg); transform: translateY(-1px); }
        .menu-button:active { background-color: var(--button-active-bg); transform: scale(0.98); }

        /* Help Screen Specifics */
         #help-screen-content { max-width: 600px; text-align: left; font-size: 0.75rem; line-height: 1.6; color: var(--text-color); }
         #help-screen h2 { font-size: 1.5rem; color: #fff; margin-bottom: 1.5rem; text-align: center; }
         #help-screen h4 { font-size: 0.9rem; color: var(--text-color-heading); margin-top: 1.5rem; margin-bottom: 0.5rem; }
         #help-screen p, #help-screen li { margin-bottom: 0.5rem; color: var(--text-color); }
         #help-screen ul { list-style: none; padding-left: 1rem; /* Indent list slightly */ }
         #help-screen code { background-color: rgba(0,0,0,0.3); padding: 0.1em 0.4em; border-radius: 4px; font-family: monospace; color: #facc15; }
         #close-help-button { margin-top: 2rem; padding: 0.6rem 1.5rem; font-size: 0.9rem; font-weight: normal; border-radius: 0.5rem; background-color: var(--accent-color); color: white; border: none; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; font-family: var(--font-display); display: block; margin-left: auto; margin-right: auto; }
         #close-help-button:hover { background-color: #2563eb; }
         #close-help-button:active { transform: scale(0.98); }


        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 1rem; color: var(--text-color); pointer-events: none; display: none; font-family: var(--font-display); font-size: 8px; }
        .ui-panel { background-color: var(--panel-bg); border: 1px solid var(--panel-border); padding: 0.75rem 1rem; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1); pointer-events: auto; width: fit-content; margin-bottom: 0.75rem; position: absolute; transition: background-color 0.3s ease, border-color 0.3s ease; }

        /* Panel Positions */
        #mission-info { line-height: 1.5; top: 1rem; left: 1rem; }
        #controls-info { bottom: 1rem; left: 1rem; font-size: 1em; }
        .ui-controls { pointer-events: auto; display: flex; gap: 0.5rem; position: absolute; top: 1rem; right: 1rem; }
        #right-column { position: absolute; top: calc(1rem + 40px + 0.5rem); right: 1rem; display: flex; flex-direction: column; align-items: flex-end; gap: 0.75rem; pointer-events: none; width: 224px; }
        #right-column .ui-panel { position: static; width: 100%; box-sizing: border-box; }
        #preview-box { text-align: center; }
        #theme-selector { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; padding: 0.75rem; }
        #lighting-controls { font-size: 1em; padding: 0.75rem; }

        /* Headings and Text */
        .ui-panel h2 { font-size: 1.2em; font-weight: normal; color: var(--text-color-heading); margin-bottom: 0.25rem; line-height: 1.2; }
        .ui-panel h3 { width: 100%; margin-bottom: 0.75rem; font-weight: normal; font-size: 1em; color: var(--text-color-muted); text-align: left; border-bottom: 1px solid var(--panel-border); padding-bottom: 0.25rem; line-height: 1.2; }
        #score-display { font-weight: normal; font-size: 1.3em; color: #facc15; }
        .ui-panel p { font-size: 1em; line-height: 1.4; margin-bottom: 0.25rem;}
        #controls-info strong { font-weight: normal; }

        /* Buttons */
        .game-button { padding: 0.5rem 1rem; border-radius: 0.5rem; background-color: var(--button-bg); color: var(--text-color-heading); font-weight: normal; border: 1px solid var(--button-border); height: 40px; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); transition: all 0.15s ease-out; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 1em; white-space: nowrap; }
        .game-button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
        .game-button:active:not(:disabled) { background-color: var(--button-active-bg); transform: scale(0.98); }
        .game-button:disabled { background-color: #374151; border-color: #4b5563; color: #9ca3af; cursor: not-allowed; transform: none; box-shadow: none; opacity: 0.6; }
        #ai-help-button { min-width: 100px; }

        .theme-button { padding: 0.5rem 0.6rem; font-size: 1em; border-radius: 0.375rem; background-color: #5a6578; color: white; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; cursor: pointer; border: 1px solid #718096; text-align: center; width: 100%; line-height: 1.1; }
        .theme-button:hover { background-color: #3d4758; }
        .theme-button.active { background-color: var(--accent-color); border-color: var(--accent-color); font-weight: normal; }

        /* Lighting Controls Styling */
        #lighting-controls label { display: block; margin-bottom: 0.1rem; color: var(--text-color-muted); font-size: 1em; line-height: 1.2; }
        #lighting-controls div { margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: space-between; }
        #lighting-controls label { flex-basis: 35%; flex-shrink: 0; margin-right: 0.5rem; }
        #lighting-controls input[type="range"] { flex-grow: 1; width: auto; min-width: 0; height: 8px; cursor: pointer; accent-color: var(--accent-color); margin: 0; }
        #lighting-controls span { display: inline-block; min-width: 2.3em; text-align: right; color: var(--text-color-heading); font-size: 1em; margin-left: 0.5rem; }

        #preview-canvas { width: 80px; height: 80px; border-radius: 0.375rem; background-color: rgba(0, 0, 0, 0.2); margin: 0 auto; }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.5rem 2.5rem; border-radius: 0.75rem; font-size: 1.2rem; text-align: center; display: none; z-index: 10; pointer-events: none; font-family: var(--font-display); line-height: 1.4; }

        /* --- Mobile Controls --- */
        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; padding: 1rem; display: flex; justify-content: space-between; align-items: flex-end; pointer-events: none; z-index: 50; }
        @media (min-width: 768px) { #mobile-controls { display: none; } }
        #d-pad, #action-buttons { pointer-events: auto; display: grid; gap: 0.5rem; }
        #d-pad { width: 130px; height: 130px; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); grid-template-areas: ". up ." "left . right" ". down ."; }
        #action-buttons { width: 130px; display: flex; flex-direction: column-reverse; align-items: center; gap: 0.75rem; }
        .mobile-button { background-color: rgba(80, 80, 90, 0.6); border: 1px solid rgba(150, 150, 150, 0.5); border-radius: 50%; width: 45px; height: 45px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.1s ease; padding: 0; }
         .mobile-button:active { background-color: rgba(110, 110, 120, 0.7); }
         .mobile-button img { width: 60%; height: 60%; filter: invert(1) brightness(0.9); }
        #btn-move-up { grid-area: up; } #btn-move-down { grid-area: down; } #btn-move-left { grid-area: left; } #btn-move-right { grid-area: right; }
        #action-buttons .mobile-button { width: 55px; height: 55px; border-radius: 0.75rem; }

        /* Additional styles from user input */
        .glow { text-shadow: 0 0 5px #00f0ff, 0 0 10px #00f0ff, 0 0 15px #00f0ff; }
        .floating { animation: float 4s ease-in-out infinite; }
        @keyframes float {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }

    </style>
</head>
<body>
    <div id="welcome-screen" class="overlay">
        <div id="welcome-bg-texture"></div>
        <h1 class="glow">3D Tetris Builder</h1>
        <p class="floating">Construct the blueprints before the blocks pile up!</p>
        <div class="mb-4">
            <input type="text" id="player-name" placeholder="Enter architect name" maxlength="20"
                   class="bg-gray-800 text-white px-4 py-2 rounded-md border border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-300" />
        </div>
        <button id="start-game-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold px-6 py-2 rounded-md transition">
            Start Building!
        </button>
    </div>

    <div id="main-menu-screen" class="overlay">
        <h1>MAIN MENU</h1>
        <button id="menu-start-button" class="menu-button">Start Game</button>
        <button id="menu-demo-button" class="menu-button">Demo</button>
        <button id="menu-help-button" class="menu-button">Help</button>
    </div>

    <div id="help-screen" class="overlay">
        <div id="help-screen-content">
            <h2>How to Play</h2>
            <h4>Goal</h4> <p>Complete the building blueprints for each mission. Falling blocks must be placed to fill the exact spots indicated by the semi-transparent 'ghost' blocks.</p>
            <h4>Controls (Keyboard)</h4> <ul> <li><code>W</code> / <code>S</code>: Move Forward / Backward</li> <li><code>A</code> / <code>D</code>: Move Left / Right</li> <li><code>Spacebar</code>: Rotate (Y-axis / Flat)</li> <li><code>Q</code> / <code>E</code>: Rotate (X-axis / Tumble)</li> <li><code>Z</code> / <code>C</code>: Rotate (Z-axis / Tilt)</li> <li><code>ArrowDown</code>: Speed Up Fall</li> <li><code>Tab</code>: Hard Drop</li> <li><code>P</code>: Pause / Resume</li> <li><code>R</code>: Return to Main Menu</li> <li><code>H</code>: Use AI Hint</li> <li>Mouse Drag: Rotate Camera</li> </ul>
             <h4>Controls (Mobile)</h4> <p>Use the on-screen D-Pad (left) for movement and buttons (right) for rotation and hard drop.</p>
            <h4>Gameplay</h4> <p>Use the controls to position the falling block. When a block lands on the ground or another block, it locks into place. If a locked block occupies a space shown in the blueprint, the corresponding ghost block will disappear. Complete the mission by filling all ghost block spots.</p>
            <h4>Scoring</h4> <ul> <li>+10 Points per cube locked.</li> <li>+50 Bonus points per cube locked in a correct blueprint spot.</li> <li>+500 Bonus points for completing a mission.</li> <li>Up to +1000 Time Bonus per mission based on speed.</li> <li>-200 Points penalty for using AI Hint.</li> </ul>
            <h4>AI Hint</h4> <ul> <li>Shows the best calculated spot for the *next* piece (using Y-rotation only for now).</li> <li>Target ghost blocks will blink for 5 seconds.</li> <li>Costs 200 points per use.</li> <li>Limited to 3 uses per game.</li> <li>Available only after placing 3 correct blocks in a mission.</li> <li>Activate with the 'H' key or the button.</li> </ul>
            <h4>Other Features</h4> <ul> <li>Use the Theme buttons to change the visual style.</li> <li>Use the Lighting sliders to adjust the scene lighting.</li> </ul>
            <button id="close-help-button">Close</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="ui-overlay"> <div id="mission-info" class="ui-panel">
                <h2>Mission: <span id="mission-name">Loading...</span></h2>
                <p>Blocks Placed: <span id="blocks-placed">0</span> / <span id="blocks-target">0</span></p>
                <p>Score: <span id="score-display">0</span></p>
            </div>
            <div class="ui-controls">
                 <button id="ai-help-button" class="game-button">AI Hint (3)</button>
                 <button id="pause-button" class="game-button">Pause</button>
                 <button id="restart-button" class="game-button">Main Menu</button>
            </div>
            <div id="right-column">
                 <div id="preview-box" class="ui-panel"> <h3>Next</h3> <canvas id="preview-canvas"></canvas> </div>
                 <div id="theme-selector" class="ui-panel"> <h3>Theme</h3> <button class="theme-button" data-theme="default">Default</button> <button class="theme-button" data-theme="milkyway">Stars</button> <button class="theme-button" data-theme="cyberpunk">Cyber</button> <button class="theme-button" data-theme="jungle">Jungle</button> <button class="theme-button" data-theme="town">Town</button> </div>
                 <div id="lighting-controls" class="ui-panel"> <h3>Lights</h3> <div><label for="hemi-intensity">Hemi:</label><input type="range" id="hemi-intensity" name="hemi-intensity" min="0" max="3" step="0.1"><span id="hemi-intensity-value">1.0</span></div> <div><label for="ambient-intensity">Amb:</label><input type="range" id="ambient-intensity" name="ambient-intensity" min="0" max="2" step="0.1"><span id="ambient-intensity-value">1.0</span></div> <div><label for="dir-intensity">Sun:</label><input type="range" id="dir-intensity" name="dir-intensity" min="0" max="5" step="0.1"><span id="dir-intensity-value">1.0</span></div> <div><label for="dir-y">Angle:</label><input type="range" id="dir-y" name="dir-y" min="1" max="30" step="1"><span id="dir-y-value">15</span></div> </div>
            </div>
            <div id="controls-info" class="ui-panel"> <strong>Controls:</strong> WASD, QE/ZC/Space(Rot), Tab(Drop), P, R, H </div>
        </div>
        <div id="message-box">Message</div>

        <div id="mobile-controls" class="md:hidden">
            <div id="d-pad">
                 <button id="btn-move-up" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/arrow-up.svg" alt="Up"/> </button>
                 <button id="btn-move-left" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/arrow-left.svg" alt="Left"/> </button>
                 <button id="btn-move-right" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/arrow-right.svg" alt="Right"/> </button>
                 <button id="btn-move-down" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/arrow-down.svg" alt="Down"/> </button>
            </div>
            <div id="action-buttons">
                 <button id="btn-hard-drop" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/arrow-down-to-line.svg" alt="Hard Drop"/> </button>
                 <button id="btn-rotate-y" class="mobile-button"> <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/rotate-cw.svg" alt="Rotate"/> </button>
            </div>
        </div>

    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        // ... (constants remain the same)
        const BOARD_WIDTH = 10; const BOARD_HEIGHT = 20; const BOARD_DEPTH = 10; const CUBE_SIZE = 1; const FALL_SPEED_NORMAL = 1000; const FALL_SPEED_FAST = 50; const LOCK_FLASH_DURATION = 250; const PARTICLE_COUNT = 50; const PARTICLE_LIFESPAN = 0.5; const PREVIEW_CANVAS_SIZE = 80; const POINTS_PER_CUBE = 10; const POINTS_PER_CORRECT_CUBE_BONUS = 50; const POINTS_MISSION_COMPLETE = 500; const MAX_TIME_BONUS = 1000; const MAX_TIME_ALLOWED_PER_MISSION = 120; const STARFIELD_RADIUS = 200; const STARFIELD_COUNT = 5000; const AI_HINT_USES = 3; const AI_HINT_COST = 200; const AI_HINT_ACTIVATE_THRESHOLD = 3; const HINT_BLINK_DURATION = 5000; const HINT_BLINK_INTERVAL = 300; const DEMO_STEP_DELAY = 400; // ms between demo steps


        // --- Game State ---
        // ... (game state variables remain the same, add isDemoMode)
        let scene, camera, renderer, controls, clock;
        let board = []; let currentPiece = null; let ghostBlocks = [];
        let lockedBlocksGroup = new THREE.Group(); let currentMissionIndex = 0;
        let fallInterval; let currentFallSpeed = FALL_SPEED_NORMAL;
        let targetBlockCount = 0; let placedTargetBlocks = 0;
        let isGameOver = false; let isPaused = false; let activeParticles = [];
        let nextPieceData = null; let totalScore = 0; let missionStartTime = 0;
        let gameStarted = false; let playerName = "Player";
        let aiHintUsesLeft = AI_HINT_USES;
        let isBlinkingHint = false; let blinkingGhostsInfo = []; let blinkIntervalId = null;
        let isDemoMode = false; // Flag for demo mode
        let demoTimeoutId = null; // Timeout ID for demo steps


        // --- Scene Elements ---
        // ... (scene elements remain the same)
        let hemisphereLight, ambientLight, directionalLight, groundPlane;
        let starfield = null;

        // --- Preview Scene State ---
        // ... (preview state remains the same)
        let previewScene, previewCamera, previewRenderer, previewPieceMesh = null;


        // --- Audio ---
        // ... (add hard drop synth)
        let synthMove, synthRotate, synthRotateX, synthRotateZ, synthLock, synthCorrectLock, synthMissionComplete, synthHardDrop;
        let backgroundMusicPlayer = null; // Added for background music
        let audioReady = false;


        // DOM Elements
        // ... (add new help elements)
        let pauseButton, restartButton, messageBox, previewCanvas, scoreDisplay, themeButtons, aiHelpButton;
        let hemiIntensitySlider, ambientIntensitySlider, dirIntensitySlider, dirYSlider;
        let hemiIntensityValueSpan, ambientIntensityValueSpan, dirIntensityValueSpan, dirYValueSpan;
        let welcomeScreen, playerNameInput, startGameButton, uiOverlay;
        let mainMenuScreen, menuStartButton, menuDemoButton, menuHelpButton;
        let helpScreen, closeHelpButton;
        let btnMoveUp, btnMoveDown, btnMoveLeft, btnMoveRight, btnRotateY, btnHardDrop; // Mobile Buttons


        // --- Loaders ---
        // ... (loaders remain the same)
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();


        // --- Textures ---
        // ... (textures remain the same)
        let groundTexture = null;


        // --- Helper Function for Placeholder Skybox URLs --- (Keep generic one)
        function createPlaceholderSkybox(bC,tC,p=''){const s=256; return [`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PZ`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NZ`];}

        // --- Theme Definitions (with UI colors and updated Town skybox) ---
        // ... (themes remain the same)
        const themes = { default: { background: new THREE.Color(0x333340), skybox: null, starfield: false, fog: { color: 0x333340, near: BOARD_DEPTH * 1.5, far: BOARD_DEPTH * 3 }, lights: { hemiSky: 0xadcafc, hemiGround: 0x404040, hemiIntensity: 1.5, ambient: 0xffffff, ambientIntensity: 0.3, dir: 0xffffff, dirIntensity: 2.0, dirY: 15 }, groundColor: 0xaaaaaa, groundTextureUrl: `https://placehold.co/64x64/cccccc/999999.png?text=+`, ui: { panelBg: 'rgba(50, 50, 64, 0.85)', panelBorder: 'rgba(100, 116, 139, 0.7)', textColor: '#e5e7eb', textColorMuted: '#9ca3af', textColorHeading: '#f3f4f6', accent: '#60a5fa' } }, milkyway: { background: new THREE.Color(0x000005), skybox: null, starfield: true, fog: null, lights: { hemiSky: 0x303050, hemiGround: 0x101020, hemiIntensity: 0.5, ambient: 0x404060, ambientIntensity: 0.15, dir: 0xaaaaff, dirIntensity: 0.8, dirY: 10 }, groundColor: 0x222222, groundTextureUrl: `https://placehold.co/64x64/222222/555555.png?text=ROCK`, ui: { panelBg: 'rgba(10, 10, 20, 0.85)', panelBorder: 'rgba(70, 70, 100, 0.7)', textColor: '#a0a0c0', textColorMuted: '#707090', textColorHeading: '#c0c0e0', accent: '#aaaaff' } }, cyberpunk: { background: new THREE.Color(0x1a0a2a), skybox: createPlaceholderSkybox('1a0a2a', 'FF00FF', 'CYBER_'), starfield: false, fog: { color: 0xff00ff, near: BOARD_DEPTH * 1.2, far: BOARD_DEPTH * 2.8 }, lights: { hemiSky: 0x00aaff, hemiGround: 0xff00aa, hemiIntensity: 1.8, ambient: 0x8888ff, ambientIntensity: 0.4, dir: 0x00ffff, dirIntensity: 1.8, dirY: 20 }, groundColor: 0x440044, groundTextureUrl: `https://placehold.co/64x64/440044/FF00FF.png?text=GRID`, ui: { panelBg: 'rgba(40, 10, 60, 0.9)', panelBorder: 'rgba(255, 0, 255, 0.5)', textColor: '#f0f', textColorMuted: '#a0a', textColorHeading: '#fff0ff', accent: '#0ff' } }, jungle: { background: new THREE.Color(0x305020), skybox: createPlaceholderSkybox('305020', 'b0d0a0', 'JUNGLE_'), starfield: false, fog: { color: 0x305020, near: BOARD_DEPTH * 0.7, far: BOARD_DEPTH * 2.2 }, lights: { hemiSky: 0xb0d0a0, hemiGround: 0x406030, hemiIntensity: 1.2, ambient: 0xeeeecc, ambientIntensity: 0.6, dir: 0xffffcc, dirIntensity: 1.5, dirY: 12 }, groundColor: 0x556B2F, groundTextureUrl: `https://placehold.co/64x64/556B2F/b0d0a0.png?text=DIRT`, ui: { panelBg: 'rgba(48, 80, 32, 0.9)', panelBorder: 'rgba(85, 107, 47, 0.7)', textColor: '#d0e0c0', textColorMuted: '#80a070', textColorHeading: '#f0fff0', accent: '#90ee90' } }, town: { background: new THREE.Color(0x87CEEB), skybox: [ 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_px.png', 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_nx.png', 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_py.png', 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_ny.png', 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_pz.png', 'https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/town_nz.png' ], starfield: false, fog: { color: 0xcccccc, near: BOARD_DEPTH * 2.5, far: BOARD_DEPTH * 5.0 }, lights: { hemiSky: 0xffffff, hemiGround: 0xaaaaaa, hemiIntensity: 1.8, ambient: 0xffffff, ambientIntensity: 0.6, dir: 0xffffee, dirIntensity: 2.2, dirY: 18 }, groundColor: 0xbbbbbb, groundTextureUrl: `https://placehold.co/64x64/bbbbbb/888888.png?text=PAVE`, ui: { panelBg: 'rgba(220, 220, 220, 0.85)', panelBorder: 'rgba(180, 180, 180, 0.7)', textColor: '#444', textColorMuted: '#777', textColorHeading: '#222', accent: '#4299e1' } } };
        let currentTheme = 'default';

        // --- Blueprint Generation Helpers --- MOVED BEFORE MISSIONS ARRAY ---
        function getBlueprintOffset(width, depth) { return { x: Math.floor((BOARD_WIDTH - width) / 2), z: Math.floor((BOARD_DEPTH - depth) / 2) }; }
        function generateSolidBlueprint(width, height, depth) { const b=[]; const o=getBlueprintOffset(width,depth); for(let y=0;y<height;y++) for(let x=0;x<width;x++) for(let z=0;z<depth;z++) b.push({x:x+o.x,y:y,z:z+o.z}); return b; }
        function generateWallBlueprint(width, height, depth) { const b=[]; const o=getBlueprintOffset(width,depth); for(let y=0;y<height;y++) for(let x=0;x<width;x++) for(let z=0;z<depth;z++) if(x===0||x===width-1||z===0||z===depth-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; }
        function generateHollowBlueprint(width, height, depth) { const b=[]; const o=getBlueprintOffset(width,depth); for(let y=0;y<height;y++) for(let x=0;x<width;x++) for(let z=0;z<depth;z++) if(x===0||x===width-1||z===0||z===depth-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; }
        function generateArchBlueprint(width, height, depth) { const b=[]; const o=getBlueprintOffset(width,depth); const ph=height-1; const sy=ph; if(width<3) return generateSolidBlueprint(width,height,depth); for(let y=0;y<ph;y++){ for(let z=0;z<depth;z++) b.push({x:o.x,y:y,z:o.z}); for(let z=0;z<depth;z++) b.push({x:o.x+width-1,y:y,z:z+o.z}); } for(let x=0;x<width;x++) for(let z=0;z<depth;z++) b.push({x:x+o.x,y:sy,z:z+o.z}); return b; }

        // --- NEW Manual Blueprint Definitions --- (Defined before use)
        const bridgeBlueprint = (() => { const b = []; const o = getBlueprintOffset(7, 1); const pH = 3; const sY = pH; for(let y=0; y<pH; y++) b.push({x:o.x+1, y:y, z:o.z}); for(let y=0; y<pH; y++) b.push({x:o.x+5, y:y, z:o.z}); for(let x=1; x<=5; x++) b.push({x:o.x+x, y:sY, z:o.z}); return b; })();
        const overhangBlueprint = (() => { const b = []; const bW=4, bD=4; const o = getBlueprintOffset(bW, bD); for(let x=0; x<bW; x++) for(let z=0; z<bD; z++) b.push({x:o.x+x, y:0, z:o.z+z}); const ohW=2, ohD=2; const ohOX = o.x + Math.floor((bW - ohW) / 2); const ohOZ = o.z - 1; for(let x=0; x<ohW; x++) for(let z=0; z<ohD; z++) b.push({x:ohOX+x, y:1, z:ohOZ+z}); return b; })();
        const crossBlueprint = (() => { const b = []; const o = getBlueprintOffset(5, 5); for (let y=0; y<2; y++) { for(let x=0; x<5; x++) b.push({x:o.x+x, y:y, z:o.z+2}); for(let z=0; z<5; z++) if(z!==2) b.push({x:o.x+2, y:y, z:o.z+z}); } return b; })();
        const gapBlueprint = (() => { const b = []; const w=4, h=2, d=4; const o = getBlueprintOffset(w, d); for (let y = 0; y < h; y++) { for (let x = 0; x < w; x++) { for (let z = 0; z < d; z++) { if (x === 0 || x === w - 1 || z === 0 || z === d - 1) { if (!(y === 0 && z === 0 && (x === 1 || x === 2))) { b.push({ x: x + o.x, y: y, z: z + o.z }); } } } } } return b; })();

        // --- Combined Missions Array ---
        const missions = [ { name: "1: Foundation", blueprint: generateSolidBlueprint(4, 1, 4) }, { name: "2: Low Walls", blueprint: generateWallBlueprint(4, 1, 4) }, { name: "3: The Pillar", blueprint: generateSolidBlueprint(1, 5, 1) }, { name: "4: Enclosure", blueprint: generateHollowBlueprint(4, 2, 4) }, { name: "5: Archway", blueprint: generateArchBlueprint(5, 3, 1) }, { name: "6: Bridge", blueprint: bridgeBlueprint }, { name: "7: Overhang", blueprint: overhangBlueprint }, { name: "8: Cross", blueprint: crossBlueprint }, { name: "9: Wall Gap", blueprint: gapBlueprint } ];

        // --- Block Definitions (Renamed from TETROMINOES) ---
        const BLOCK_DEFINITIONS = {
            'I':    { color: 0x00FFFF, shape: [[0,0,0], [-1,0,0], [1,0,0], [2,0,0]] }, // Cyan
            'O':    { color: 0xFFFF00, shape: [[0,0,0], [1,0,0], [0,1,0], [1,1,0]] }, // Yellow
            'T':    { color: 0x800080, shape: [[0,0,0], [-1,0,0], [1,0,0], [0,1,0]] }, // Purple
            'L':    { color: 0xFFA500, shape: [[0,0,0], [-1,0,0], [1,0,0], [1,1,0]] }, // Orange
            'J':    { color: 0x0000FF, shape: [[0,0,0], [-1,0,0], [1,0,0], [-1,1,0]] }, // Blue
            'S':    { color: 0x00FF00, shape: [[0,0,0], [-1,0,0], [0,1,0], [1,1,0]] }, // Green
            'Z':    { color: 0xFF0000, shape: [[0,0,0], [1,0,0], [0,1,0], [-1,1,0]] }, // Red
            'CUBE': { color: 0xaaaaaa, shape: [[0,0,0]] },                             // Gray
            'BEAM2':{ color: 0xcc66cc, shape: [[0,0,0], [1,0,0]] },                     // Magenta
            'BEAM3':{ color: 0x66ccff, shape: [[0,0,0], [1,0,0], [2,0,0]] },           // Light Blue
            'CORNER':{color: 0xff9933, shape: [[0,0,0], [1,0,0], [0,1,0]] }            // Orange-Yellow
        };
        const BLOCK_KEYS = Object.keys(BLOCK_DEFINITIONS); // Renamed


        // --- Initialization ---
        function init() {
            // console.log("DEBUG: init() called"); // DEBUG
            clock = new THREE.Clock();
            // Get UI Elements
            uiOverlay = document.getElementById('ui-overlay'); pauseButton = document.getElementById('pause-button'); restartButton = document.getElementById('restart-button'); messageBox = document.getElementById('message-box'); previewCanvas = document.getElementById('preview-canvas'); scoreDisplay = document.getElementById('score-display'); themeButtons = document.querySelectorAll('.theme-button'); aiHelpButton = document.getElementById('ai-help-button'); welcomeScreen = document.getElementById('welcome-screen'); playerNameInput = document.getElementById('player-name'); startGameButton = document.getElementById('start-game-button');
            // Menu Elements
            mainMenuScreen = document.getElementById('main-menu-screen'); menuStartButton = document.getElementById('menu-start-button'); menuDemoButton = document.getElementById('menu-demo-button'); menuHelpButton = document.getElementById('menu-help-button');
            // Help Screen Elements
            helpScreen = document.getElementById('help-screen'); closeHelpButton = document.getElementById('close-help-button');
            // Lighting Control Elements
            hemiIntensitySlider = document.getElementById('hemi-intensity'); ambientIntensitySlider = document.getElementById('ambient-intensity'); dirIntensitySlider = document.getElementById('dir-intensity'); dirYSlider = document.getElementById('dir-y'); hemiIntensityValueSpan = document.getElementById('hemi-intensity-value'); ambientIntensityValueSpan = document.getElementById('ambient-intensity-value'); dirIntensityValueSpan = document.getElementById('dir-intensity-value'); dirYValueSpan = document.getElementById('dir-y-value');
            // Mobile Control Buttons
            btnMoveUp = document.getElementById('btn-move-up'); btnMoveDown = document.getElementById('btn-move-down'); btnMoveLeft = document.getElementById('btn-move-left'); btnMoveRight = document.getElementById('btn-move-right'); btnRotateY = document.getElementById('btn-rotate-y'); btnHardDrop = document.getElementById('btn-hard-drop');

            // --- Initialize Audio Synths ---
            setupAudio();

            // --- Main Scene Setup ---
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(BOARD_WIDTH/2, BOARD_HEIGHT*0.8, BOARD_DEPTH*1.6); camera.lookAt(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2); renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0;

            // --- Create Lights ---
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.0); scene.add(hemisphereLight); ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight); directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(8, 15, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; const shadowCamSize = Math.max(BOARD_WIDTH, BOARD_DEPTH)*0.8; directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize; directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize; directionalLight.shadow.bias = -0.0005; scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement); controls.target.set(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2); controls.enablePan = true; controls.maxPolarAngle = Math.PI/2 - 0.05; controls.minDistance = 5; controls.maxDistance = 50; controls.enableDamping = true; controls.dampingFactor = 0.05; controls.update();
            // loadTextures(); // Removed initial ground texture load
            createBoardVisuals();
            lockedBlocksGroup.castShadow = true; lockedBlocksGroup.receiveShadow = true; scene.add(lockedBlocksGroup);
            initBoard(); initPreviewRenderer();

            // --- Apply Default Theme (before game starts) ---
            applyTheme('default');

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            pauseButton.addEventListener('click', togglePause);
            restartButton.addEventListener('click', goToMainMenu); // Use new function
            aiHelpButton.addEventListener('click', useAiHint);
            themeButtons.forEach(button => { button.addEventListener('click', () => { applyTheme(button.dataset.theme); }); });
            hemiIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); hemisphereLight.intensity=v; hemiIntensityValueSpan.textContent=v.toFixed(1); }); ambientIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); ambientLight.intensity=v; ambientIntensityValueSpan.textContent=v.toFixed(1); }); dirIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.intensity=v; dirIntensityValueSpan.textContent=v.toFixed(1); }); dirYSlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.position.y=v; dirYValueSpan.textContent=v.toFixed(0); });
            // Welcome Screen Button
            startGameButton.addEventListener('click', showMainMenu);
            playerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') showMainMenu(); });
            // Main Menu Buttons
            menuStartButton.addEventListener('click', () => { mainMenuScreen.style.display = 'none'; initializeAndStartGameplay(); });
            menuDemoButton.addEventListener('click', () => { mainMenuScreen.style.display = 'none'; initializeAndStartGameplay(true); });
            menuHelpButton.addEventListener('click', () => { mainMenuScreen.style.display = 'none'; helpScreen.style.display = 'flex'; });
            // Help Screen Close Button
            closeHelpButton.addEventListener('click', () => { helpScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; });
            // Mobile Control Button Listeners
            btnMoveUp.addEventListener('click', () => movePiece(0,0,-1, true)); // W
            btnMoveDown.addEventListener('click', () => movePiece(0,0,1, true));  // S
            btnMoveLeft.addEventListener('click', () => movePiece(-1,0,0, true)); // A
            btnMoveRight.addEventListener('click', () => movePiece(1,0,0, true)); // D
            btnRotateY.addEventListener('click', rotatePieceY);                   // Space
            btnHardDrop.addEventListener('click', hardDrop);                     // Tab

            animate(); // Start rendering loop
        }

        // --- Remaining Functions (initializeAndStartGameplay, showMainMenu, setupAudio, etc.) ---
        // ... (No changes needed in the rest of the JavaScript logic from previous version) ...
        // Renamed from startGame
        async function initializeAndStartGameplay(demo = false) { // Added demo flag
             // --- Start Audio Context ---
             // console.log("DEBUG: Attempting to start audio context..."); // DEBUG
             if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') { try { await Tone.start(); audioReady = true; console.log('Audio context started!'); if(backgroundMusicPlayer && backgroundMusicPlayer.loaded && !isDemoMode) backgroundMusicPlayer.start(); /* Start music if loaded */ } catch (error) { console.error("Failed to start Tone.js audio context:", error); audioReady = false; } } else if (typeof Tone !== 'undefined' && Tone.context.state === 'running') { audioReady = true; if(backgroundMusicPlayer && backgroundMusicPlayer.loaded && !isDemoMode) backgroundMusicPlayer.start(); /* Start music if loaded */ } else { console.warn("Tone.js library not loaded."); audioReady = false; }
             // ---

            uiOverlay.style.display = 'block'; // Show game UI
            // console.log("DEBUG: uiOverlay display set to block"); // DEBUG

            isDemoMode = demo;
            gameStarted = true; isPaused = false; isGameOver = false;
            totalScore = 0; currentMissionIndex = 0;
            aiHintUsesLeft = AI_HINT_USES;
            nextPieceData = determineNextPiece(); // Use new function name
            // console.log("DEBUG: Calling loadMission(0)"); // DEBUG
            loadMission(currentMissionIndex); // Load mission 0

            if (isDemoMode) {
                console.log("Starting Demo Mode...");
                showMessage("Demo Mode Running...", 0);
                controls.enabled = false;
                 if(backgroundMusicPlayer) backgroundMusicPlayer.stop(); // No music in demo for now
                runDemoStep();
            } else {
                console.log("Gameplay Started!");
                controls.enabled = true;
                // Music started via Tone.start() check above
            }
        }

        // Called when welcome screen button is clicked
        function showMainMenu() {
             // console.log("DEBUG: showMainMenu called"); // DEBUG
             const name = playerNameInput.value.trim();
             if (name) { playerName = name; console.log(`Player Name: ${playerName}`); }
             else { console.log("No name entered, using default."); }

             welcomeScreen.style.display = 'none';
             mainMenuScreen.style.display = 'flex'; // Show the main menu
        }


        async function setupAudio() { /* ... same as before ... */ try { if(typeof Tone === 'undefined'){ console.error("Tone is not defined!"); audioReady = false; return;} synthMove = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }, volume: -20 }).toDestination(); synthRotate = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.1 }, volume: -18 }).toDestination(); synthRotateX = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.002, decay: 0.07, sustain: 0, release: 0.1 }, volume: -19 }).toDestination(); synthRotateZ = new Tone.Synth({ oscillator: { type: 'pulse' , width: 0.3}, envelope: { attack: 0.001, decay: 0.06, sustain: 0, release: 0.1 }, volume: -19 }).toDestination(); synthLock = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 3, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }, volume: -12 }).toDestination(); synthCorrectLock = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -15 }).toDestination(); synthMissionComplete = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.4 }, volume: -10 }).toDestination(); synthHardDrop = new Tone.MembraneSynth({ pitchDecay: 0.005, octaves: 4, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }, volume: -10 }).toDestination(); const musicUrl = "https://raw.githubusercontent.com/HafizalJohari/3dtetris/main/Falling%20Blocks.mp3"; backgroundMusicPlayer = new Tone.Player({ url: musicUrl, loop: true, autostart: false, volume: -18, onload: () => { console.log("Background music loaded successfully!"); }, onerror: (error) => { console.error("Error loading background music:", error); } }).toDestination(); console.log("Audio synths created."); } catch (error) { console.error("Error creating Tone.js synths:", error); audioReady = false; } }
        function initPreviewRenderer() { /* ... same as before ... */ previewScene=new THREE.Scene(); previewScene.background=null; const a=PREVIEW_CANVAS_SIZE/PREVIEW_CANVAS_SIZE; const fS=4*CUBE_SIZE; previewCamera=new THREE.OrthographicCamera(fS*a/-2,fS*a/2,fS/2,fS/-2,0.1,100); previewCamera.position.set(0,0,5); previewCamera.lookAt(0,0,0); previewRenderer=new THREE.WebGLRenderer({canvas:previewCanvas,antialias:true,alpha:true}); previewRenderer.setSize(PREVIEW_CANVAS_SIZE,PREVIEW_CANVAS_SIZE); previewRenderer.setPixelRatio(window.devicePixelRatio); previewRenderer.toneMapping=THREE.ACESFilmicToneMapping; previewRenderer.toneMappingExposure=1.0; const pA=new THREE.AmbientLight(0xffffff,1.0); previewScene.add(pA); const pL=new THREE.DirectionalLight(0xffffff,1.5); pL.position.set(1,2,3); previewScene.add(pL); }
        function loadTextures() { /* No longer loads ground texture here */ }
        function initBoard() { /* ... same as before ... */ board=Array(BOARD_WIDTH).fill(null).map(()=>Array(BOARD_HEIGHT).fill(null).map(()=>Array(BOARD_DEPTH).fill(0))); }
        function createBoardVisuals() { /* ... same as before ... */ const gH=new THREE.GridHelper(Math.max(BOARD_WIDTH,BOARD_DEPTH),Math.max(BOARD_WIDTH,BOARD_DEPTH),0x888888,0x444444); gH.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2+0.01,BOARD_DEPTH/2-CUBE_SIZE/2); scene.add(gH); const gG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_DEPTH*CUBE_SIZE); const gM=new THREE.MeshStandardMaterial({color:0xaaaaaa,map:null,side:THREE.DoubleSide,roughness:0.8,metalness:0.2}); groundPlane=new THREE.Mesh(gG,gM); groundPlane.name="groundPlane"; groundPlane.rotation.x=-Math.PI/2; groundPlane.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); groundPlane.receiveShadow=true; scene.add(groundPlane); const wM=new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.05,side:THREE.DoubleSide}); const bWG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const bW=new THREE.Mesh(bWG,wM); bW.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,-CUBE_SIZE/2); scene.add(bW); const lWG=new THREE.PlaneGeometry(BOARD_DEPTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const lW=new THREE.Mesh(lWG,wM); lW.position.set(-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); lW.rotation.y=Math.PI/2; scene.add(lW); const rW=lW.clone(); rW.position.x=BOARD_WIDTH-CUBE_SIZE/2; scene.add(rW); }

        // --- Starfield ---
        function createStarfield(){ if(starfield)removeStarfield(); const v=[]; for(let i=0;i<STARFIELD_COUNT;i++){ const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const r=STARFIELD_RADIUS*Math.cbrt(Math.random()); const x=r*Math.sin(ph)*Math.cos(th); const y=r*Math.sin(ph)*Math.sin(th); const z=r*Math.cos(ph); v.push(x,y,z); } const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); const m=new THREE.PointsMaterial({color:0xffffff,size:0.15,sizeAttenuation:true,transparent:true,opacity:0.8}); starfield=new THREE.Points(g,m); starfield.name="starfield"; scene.add(starfield); console.log("Starfield created."); }
        function removeStarfield(){ if(starfield){ scene.remove(starfield); starfield.geometry.dispose(); starfield.material.dispose(); starfield=null; console.log("Starfield removed."); } }

        // --- Theme Application ---
        function applyTheme(themeName) { /* ... same as before ... */ const theme=themes[themeName]; if(!theme){console.warn(`Theme "${themeName}" not found.`); return;} console.log(`Applying theme: ${themeName}`); currentTheme=themeName; removeStarfield(); if(scene.background&&scene.background.isTexture){scene.background=null;} if(theme.starfield){scene.background=theme.background; createStarfield();}else if(theme.skybox&&theme.skybox.length===6){scene.background=theme.background; cubeTextureLoader.load(theme.skybox,(t)=>{scene.background=t; console.log(`${themeName} skybox loaded.`);},undefined,(e)=>{console.error(`Skybox error ${themeName}:`,e); scene.background=theme.background;});}else{scene.background=theme.background;} if(theme.fog){if(!scene.fog){scene.fog=new THREE.Fog(theme.fog.color,theme.fog.near,theme.fog.far);}else{scene.fog.color.set(theme.fog.color); scene.fog.near=theme.fog.near; scene.fog.far=theme.fog.far;}}else{scene.fog=null;} if(theme.lights){hemisphereLight.color.setHex(theme.lights.hemiSky); hemisphereLight.groundColor.setHex(theme.lights.hemiGround); hemisphereLight.intensity=theme.lights.hemiIntensity; ambientLight.color.setHex(theme.lights.ambient); ambientLight.intensity=theme.lights.ambientIntensity; directionalLight.color.setHex(theme.lights.dir); directionalLight.intensity=theme.lights.dirIntensity; directionalLight.position.y=theme.lights.dirY; if(hemiIntensitySlider)hemiIntensitySlider.value=theme.lights.hemiIntensity; if(hemiIntensityValueSpan)hemiIntensityValueSpan.textContent=theme.lights.hemiIntensity.toFixed(1); if(ambientIntensitySlider)ambientIntensitySlider.value=theme.lights.ambientIntensity; if(ambientIntensityValueSpan)ambientIntensityValueSpan.textContent=theme.lights.ambientIntensity.toFixed(1); if(dirIntensitySlider)dirIntensitySlider.value=theme.lights.dirIntensity; if(dirIntensityValueSpan)dirIntensityValueSpan.textContent=theme.lights.dirIntensity.toFixed(1); if(dirYSlider)dirYSlider.value=theme.lights.dirY; if(dirYValueSpan)dirYValueSpan.textContent=theme.lights.dirY.toFixed(0);} if (groundPlane && groundPlane.material) { if (theme.groundTextureUrl) { textureLoader.load( theme.groundTextureUrl, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(BOARD_WIDTH, BOARD_DEPTH); groundPlane.material.map = texture; groundPlane.material.color.set(0xffffff); groundPlane.material.needsUpdate = true; console.log(`Ground texture loaded for ${themeName}`); }, undefined, (error) => { console.error(`Error loading ground texture for ${themeName}:`, error); groundPlane.material.map = null; groundPlane.material.color.setHex(theme.groundColor); groundPlane.material.needsUpdate = true; } ); } else { groundPlane.material.map = null; groundPlane.material.color.setHex(theme.groundColor); groundPlane.material.needsUpdate = true; } } const rootStyle=document.documentElement.style; if(theme.ui){rootStyle.setProperty('--panel-bg',theme.ui.panelBg); rootStyle.setProperty('--panel-border',theme.ui.panelBorder); rootStyle.setProperty('--text-color',theme.ui.textColor); rootStyle.setProperty('--text-color-muted',theme.ui.textColorMuted); rootStyle.setProperty('--text-color-heading',theme.ui.textColorHeading); rootStyle.setProperty('--accent-color',theme.ui.accent); rootStyle.setProperty('--button-bg',theme.ui.buttonBg||'#4b5563'); rootStyle.setProperty('--button-border',theme.ui.buttonBorder||'#6b7280'); rootStyle.setProperty('--button-hover-bg',theme.ui.buttonHoverBg||'#374151');} if(themeButtons)themeButtons.forEach(button=>{button.classList.toggle('active',button.dataset.theme===themeName);}); }


        // --- Mission Handling --- (Unchanged)
        function loadMission(mI, isR=false){ if(!gameStarted) return; if(fallInterval)clearInterval(fallInterval); fallInterval=null; if(!isR&&mI>=missions.length){showMessage(`All Missions Complete! Final Score: ${totalScore}`);gameOver(true);return;} if(mI>=missions.length){mI=missions.length-1;} const m=missions[mI]; console.log(`Loading Mission: ${m.name}`); clearBoard(); clearGhostBlocks(); if(currentPiece){scene.remove(currentPiece.mesh);currentPiece=null;} placedTargetBlocks=0; targetBlockCount=m.blueprint.length; // Use m.blueprint here
        displayBlueprint(m.blueprint); // Use m.blueprint here
        document.getElementById('mission-name').textContent=m.name; isGameOver=false; isPaused=false; pauseButton.textContent='Pause'; hideMessage(); missionStartTime=clock.getElapsedTime(); updateUI(); if(!isR||!nextPieceData){nextPieceData=determineNextPiece();} updatePreview(nextPieceData); spawnPiece(); if(currentPiece&&!isGameOver&&!isDemoMode){currentFallSpeed=FALL_SPEED_NORMAL;startGameLoop();}else if(isGameOver){console.log("GO on load.");} }
        function displayBlueprint(b){ /* ... same as before ... */ const gm=new THREE.MeshStandardMaterial({color:0xaaaaaa,transparent:true,opacity:0.25,roughness:0.9}); const gg=new THREE.BoxGeometry(CUBE_SIZE*0.95,CUBE_SIZE*0.95,CUBE_SIZE*0.95); b.forEach(c=>{ if(c.x<0||c.x>=BOARD_WIDTH||c.y<0||c.y>=BOARD_HEIGHT||c.z<0||c.z>=BOARD_DEPTH){console.warn("BP coord out:",c);return;} const gc=new THREE.Mesh(gg,gm.clone()); gc.position.set(c.x*CUBE_SIZE,c.y*CUBE_SIZE,c.z*CUBE_SIZE); gc.userData.isGhost=true; gc.userData.originalPosition={x:c.x,y:c.y,z:c.z}; gc.userData.baseOpacity = gm.opacity; scene.add(gc); ghostBlocks.push(gc);}); targetBlockCount=ghostBlocks.length; updateUI();}
        function clearGhostBlocks() { stopBlinkingHint(); ghostBlocks.forEach(g => { scene.remove(g); }); ghostBlocks = []; }
        function checkMissionCompletion(){
            if(isGameOver || !gameStarted)return false;
            if(placedTargetBlocks>=targetBlockCount&&targetBlockCount>0){
                stopBlinkingHint();
                const mN=missions[currentMissionIndex].name;

                if (isDemoMode) {
                    showMessage(`Demo Complete!`, 2000); setTimeout(goToMainMenu, 2100); return true;
                } else {
                    let mCB=POINTS_MISSION_COMPLETE; const tT=clock.getElapsedTime()-missionStartTime; const tBR=Math.max(0,1.0-(tT/MAX_TIME_ALLOWED_PER_MISSION)); let tB=Math.round(MAX_TIME_BONUS*tBR); totalScore+=mCB; totalScore+=tB; updateUI(); showMessage(`Mission ${mN} Complete!\nScore +${mCB} +${tB} (Time)`,3500); const cP=new THREE.Vector3(BOARD_WIDTH/2*CUBE_SIZE,0,BOARD_DEPTH/2*CUBE_SIZE); createParticleEffect(cP,0xffd700,150,1.5); currentMissionIndex++; if(fallInterval)clearInterval(fallInterval); fallInterval=null;
                    if (audioReady && synthMissionComplete) { const now = Tone.now(); synthMissionComplete.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now); synthMissionComplete.triggerAttackRelease("E5", "4n", now + Tone.Time("4n").toSeconds()); }
                    setTimeout(()=>{loadMission(currentMissionIndex);},3600);
                    return true;
                }
            }
            return false;
        }

        // --- Game Loop & Piece Logic --- (Unchanged)
        function startGameLoop(){ if(isPaused||isGameOver||!gameStarted||isDemoMode)return; /* Don't run interval in demo */ if(fallInterval)clearInterval(fallInterval); fallInterval=setInterval(()=>{if(!isPaused&&!isGameOver&&currentPiece&&gameStarted&&!isDemoMode){movePiece(0,-1,0);}},currentFallSpeed); /* console.log("Timer start/reset:",currentFallSpeed); */ } // Quieten log
        function stopGameLoop(){ if(fallInterval){clearInterval(fallInterval); fallInterval=null;} if (demoTimeoutId) { clearTimeout(demoTimeoutId); demoTimeoutId = null;} } // Also stop demo timer
        function resetFallTimer(){ if(!isPaused&&!isGameOver&&gameStarted&&!isDemoMode){startGameLoop();} } // Don't run in demo
        function determineNextPiece(){ const k=BLOCK_KEYS[Math.floor(Math.random()*BLOCK_KEYS.length)]; const d=BLOCK_DEFINITIONS[k]; return {type:k, color:d.color, shape:JSON.parse(JSON.stringify(d.shape))}; } // Use new names
        function spawnPiece(){ if(isGameOver||isPaused||!gameStarted)return; if(!nextPieceData){console.warn("nextPD null."); nextPieceData=determineNextPiece();} const cPD=nextPieceData; nextPieceData=determineNextPiece(); updatePreview(nextPieceData); const sX=Math.floor(BOARD_WIDTH/2); const sY=BOARD_HEIGHT - 2; /* Adjusted spawn height */ const sZ=Math.floor(BOARD_DEPTH/2); const pG=new THREE.Group(); const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:cPD.color,metalness:0.3,roughness:0.5}); cPD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); c.castShadow=true; c.receiveShadow=false; pG.add(c); }); currentPiece={mesh:pG,shape:cPD.shape,x:sX,y:sY,z:sZ,rotationY:0, rotationX: 0, rotationZ: 0}; currentPiece.mesh.position.set(sX*CUBE_SIZE,sY*CUBE_SIZE,sZ*CUBE_SIZE); if(!isValidMove(currentPiece.x,currentPiece.y,currentPiece.z,currentPiece.shape)){console.log("Game Over on spawn!"); gameOver(); currentPiece=null; if(nextPieceData)updatePreview(nextPieceData); return;} scene.add(currentPiece.mesh); /* console.log("Spawned:",cPD.type,"Next:",nextPieceData.type); */ updateUI(); }
        function movePiece(dx,dy,dz, userInitiated = false){ if(!currentPiece||isPaused||isGameOver||!gameStarted)return; stopBlinkingHint(); const nX=currentPiece.x+dx; const nY=currentPiece.y+dy; const nZ=currentPiece.z+dz; if(isValidMove(nX,nY,nZ,currentPiece.shape)){ currentPiece.x=nX; currentPiece.y=nY; currentPiece.z=nZ; currentPiece.mesh.position.set(currentPiece.x*CUBE_SIZE,currentPiece.y*CUBE_SIZE,currentPiece.z*CUBE_SIZE); if (userInitiated && audioReady && synthMove) { synthMove.triggerAttackRelease("C5", "32n", Tone.now()); } } else if(dy<0){ lockPiece(); if(!isGameOver && !isDemoMode){ spawnPiece(); if(currentFallSpeed!==FALL_SPEED_NORMAL){ currentFallSpeed=FALL_SPEED_NORMAL; resetFallTimer(); } } else if (!isGameOver && isDemoMode) { runDemoStep(); /* Trigger next demo step after lock */ } } }

        // Generic rotation function
        function rotatePiece(axis, angle) {
            if(!currentPiece||isPaused||isGameOver||!gameStarted)return false;
            stopBlinkingHint();

            const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            const tempVec = new THREE.Vector3();
            const rotatedShape = currentPiece.shape.map(offset => {
                tempVec.set(offset[0], offset[1], offset[2]);
                tempVec.applyQuaternion(quaternion);
                return [Math.round(tempVec.x), Math.round(tempVec.y), Math.round(tempVec.z)];
            });

            if(isValidMove(currentPiece.x, currentPiece.y, currentPiece.z, rotatedShape)){
                currentPiece.mesh.applyQuaternion(quaternion);
                currentPiece.shape = rotatedShape;
                return true;
            } else {
                console.log("Rotation blocked");
                return false;
            }
        }

        function rotatePieceY(){ if (rotatePiece(new THREE.Vector3(0, 1, 0), Math.PI / 2)) { if (audioReady && synthRotate) synthRotate.triggerAttackRelease("E5", "16n", Tone.now()); } }
        function rotatePieceX(clockwise = true){ const angle = clockwise ? Math.PI / 2 : -Math.PI / 2; if (rotatePiece(new THREE.Vector3(1, 0, 0), angle)) { if (audioReady && synthRotateX) synthRotateX.triggerAttackRelease("F#5", "16n", Tone.now()); } }
        function rotatePieceZ(clockwise = true){ const angle = clockwise ? Math.PI / 2 : -Math.PI / 2; if (rotatePiece(new THREE.Vector3(0, 0, 1), angle)) { if (audioReady && synthRotateZ) synthRotateZ.triggerAttackRelease("G#5", "16n", Tone.now()); } }

        function isValidMove(bX,bY,bZ,sh){ /* Allow check even if game not started for AI/Demo */ for(const o of sh){ const wX=bX+o[0]; const wY=bY+o[1]; const wZ=bZ+o[2]; if(wX<0||wX>=BOARD_WIDTH||wY<0||wZ<0||wZ>=BOARD_DEPTH)return false; if(wY>=BOARD_HEIGHT)continue; if(board[wX][wY][wZ]!==0)return false; } return true; }
        function lockPiece(){ if(!currentPiece||isGameOver||!gameStarted)return; stopBlinkingHint(); /* console.log("Locking:",currentPiece.x,currentPiece.y,currentPiece.z); */ let mPM=false; const pM=currentPiece.mesh.children[0].material; let sGTL=0; currentPiece.shape.forEach(o=>{ const wX=currentPiece.x+o[0]; const wY=currentPiece.y+o[1]; const wZ=currentPiece.z+o[2]; if(wX>=0&&wX<BOARD_WIDTH&&wY>=0&&wY<BOARD_HEIGHT&&wZ>=0&&wZ<BOARD_DEPTH){ const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=pM.clone(); const lC=new THREE.Mesh(geo,mat); lC.position.set(wX*CUBE_SIZE,wY*CUBE_SIZE,wZ*CUBE_SIZE); lC.castShadow=true; lC.receiveShadow=true; lockedBlocksGroup.add(lC); board[wX][wY][wZ]=1; if (!isDemoMode) totalScore+=POINTS_PER_CUBE; sGTL+=POINTS_PER_CUBE; const fGI=ghostBlocks.findIndex(g=>g.visible&&g.userData.originalPosition.x===wX&&g.userData.originalPosition.y===wY&&g.userData.originalPosition.z===wZ); if(fGI!==-1){ ghostBlocks[fGI].visible=false; placedTargetBlocks++; mPM=true; /* console.log("BP filled!"); */ if (!isDemoMode) totalScore+=POINTS_PER_CORRECT_CUBE_BONUS; sGTL+=POINTS_PER_CORRECT_CUBE_BONUS; const pP=lC.position.clone(); createParticleEffect(pP,mat.color); const oE=mat.emissive.getHex(); mat.emissive.setHex(0xffffff); mat.needsUpdate=true; setTimeout(()=>{if(lC.parent){mat.emissive.setHex(oE); mat.needsUpdate=true;}},LOCK_FLASH_DURATION); } }else{ console.warn("Lock out:",wX,wY,wZ); if(wY>=BOARD_HEIGHT){console.log("Lock above - GO."); if(currentPiece&&currentPiece.mesh.parent)scene.remove(currentPiece.mesh); currentPiece=null; gameOver(); return;} } }); if(currentPiece&&currentPiece.mesh.parent){scene.remove(currentPiece.mesh);} currentPiece=null; /* console.log(`Score gain lock: ${sGTL}`); */ if (audioReady && !isDemoMode) { if (mPM && synthCorrectLock) { synthCorrectLock.triggerAttackRelease("G5", "16n", Tone.now()); } if (synthLock) { synthLock.triggerAttackRelease("C2", "8n", Tone.now() + 0.01); } } updateUI(); if(!isGameOver&&mPM){checkMissionCompletion();} }
        function clearBoard(){ initBoard(); while(lockedBlocksGroup.children.length>0){ const o=lockedBlocksGroup.children[0]; if(o.geometry)o.geometry.dispose(); if(o.material){if(Array.isArray(o.material))o.material.forEach(m=>m.dispose()); else o.material.dispose();} lockedBlocksGroup.remove(o); } activeParticles.forEach(p=>scene.remove(p.mesh)); activeParticles=[]; removeStarfield(); }
        function gameOver(isC=false){ console.log("GO. All complete:",isC); isGameOver=true; stopGameLoop(); stopBlinkingHint(); if(backgroundMusicPlayer) backgroundMusicPlayer.stop(); if(!isC)showMessage(`Game Over! Final Score: ${totalScore}`); updateUI(); }

        // --- UI Functions ---
        function updateUI(){ if(!gameStarted && !isGameOver && !isDemoMode) return; // Don't update UI before start, but update on Game Over or during Demo
             if(scoreDisplay) scoreDisplay.textContent = isDemoMode ? "DEMO" : totalScore; // Show DEMO instead of score
             if(document.getElementById('blocks-placed')) document.getElementById('blocks-placed').textContent=placedTargetBlocks;
             if(document.getElementById('blocks-target')) document.getElementById('blocks-target').textContent=targetBlockCount;
             if (aiHelpButton) { aiHelpButton.textContent = `AI Hint (${aiHintUsesLeft})`; aiHelpButton.disabled = (isDemoMode || aiHintUsesLeft <= 0 || isPaused || isGameOver || !nextPieceData || placedTargetBlocks < AI_HINT_ACTIVATE_THRESHOLD || !gameStarted); } // Disable in demo
             if(pauseButton) pauseButton.disabled = isGameOver || !gameStarted || isDemoMode; // Disable in demo
             if(restartButton) restartButton.disabled = !gameStarted; // Disable restart if game not started (on welcome/menu)
        }
        function showMessage(t,d=3000){ messageBox.textContent=t; messageBox.style.display='block'; if(d>0){setTimeout(()=>{if(messageBox.textContent===t)hideMessage();},d);} }
        function hideMessage(){ messageBox.style.display='none'; }
        function togglePause(){
            if(isGameOver||!gameStarted||isDemoMode)return; /* No pause in demo */
            isPaused=!isPaused; console.log("Paused:",isPaused);
            if(isPaused){
                stopGameLoop(); stopBlinkingHint();
                if(backgroundMusicPlayer) backgroundMusicPlayer.stop(); // Stop music on pause
                showMessage("Paused",0); pauseButton.textContent='Resume';
            } else {
                hideMessage(); pauseButton.textContent='Pause';
                if(backgroundMusicPlayer && backgroundMusicPlayer.loaded) backgroundMusicPlayer.start(); // Resume music
                if(currentPiece)startGameLoop();
                else{ console.log("Resume no piece, spawn."); spawnPiece(); if(currentPiece&&!isGameOver)startGameLoop(); }
            }
            updateUI();
        }

        // Renamed from restartMission
        function goToMainMenu() {
            // console.log("DEBUG: goToMainMenu called"); // DEBUG
            stopGameLoop(); // Stops interval and demo timeout
            stopBlinkingHint();
            if (backgroundMusicPlayer) backgroundMusicPlayer.stop(); // Stop music
            isGameOver = false; isPaused = false; gameStarted = false; isDemoMode = false; // Reset all flags
            hideMessage();

            clearBoard(); // Resets board array, clears locked blocks, removes starfield
            if (currentPiece) { scene.remove(currentPiece.mesh); currentPiece = null; }
            ghostBlocks = []; updatePreview(null);
            aiHintUsesLeft = AI_HINT_USES; // Reset hints

            uiOverlay.style.display = 'none'; // Hide game UI
            mainMenuScreen.style.display = 'flex'; // Show main menu
            welcomeScreen.style.display = 'none';
            helpScreen.style.display = 'none'; // Ensure help screen is hidden too
            controls.enabled = true; // Ensure camera controls re-enabled
        }

        // --- Preview Update --- (Unchanged)
        function updatePreview(pD){ if(!previewScene)return; if(previewPieceMesh){previewScene.remove(previewPieceMesh);} if(!pD)return; const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:pD.color,metalness:0.3,roughness:0.5}); previewPieceMesh=new THREE.Group(); pD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); previewPieceMesh.add(c); }); const box=new THREE.Box3().setFromObject(previewPieceMesh); const center=box.getCenter(new THREE.Vector3()); previewPieceMesh.position.sub(center); previewScene.add(previewPieceMesh); /* console.log("Preview:",pD.type); */ } // Quieten preview log

        // --- Particle System --- (Unchanged)
        function createParticleEffect(p,c=0xffffff,co=PARTICLE_COUNT,l=PARTICLE_LIFESPAN){ const pg=new THREE.BufferGeometry(); const v=[]; const ve=[]; const st=[]; for(let i=0;i<co;i++){ v.push(0,0,0); const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const sp=1+Math.random()*3; ve.push(Math.sin(ph)*Math.cos(th)*sp,Math.cos(ph)*sp,Math.sin(ph)*Math.sin(th)*sp); st.push(clock.getElapsedTime()); } pg.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); pg.setAttribute('velocity',new THREE.Float32BufferAttribute(ve,3)); pg.setAttribute('startTime',new THREE.Float32BufferAttribute(st,1)); const pm=new THREE.PointsMaterial({color:c,size:0.1,transparent:true,opacity:0.8,sizeAttenuation:true,depthWrite:false,blending:THREE.AdditiveBlending}); const pt=new THREE.Points(pg,pm); pt.position.copy(p); scene.add(pt); activeParticles.push({mesh:pt,geometry:pg,material:pm,startTime:clock.getElapsedTime(),lifespan:l}); }
        function updateParticles(dt){ const ct=clock.getElapsedTime(); for(let i=activeParticles.length-1;i>=0;i--){ const s=activeParticles[i]; const et=ct-s.startTime; if(et>s.lifespan){ scene.remove(s.mesh); s.geometry.dispose(); s.material.dispose(); activeParticles.splice(i,1); continue; } const ps=s.geometry.attributes.position; const vs=s.geometry.attributes.velocity; for(let j=0;j<ps.count;j++){ const ix=j*3; const pST=s.geometry.attributes.startTime.array[j]; const pET=ct-pST; ps.array[ix]+=vs.array[ix]*dt; ps.array[ix+1]+=vs.array[ix+1]*dt-0.5*9.8*pET*dt; ps.array[ix+2]+=vs.array[ix+2]*dt; } ps.needsUpdate=true; s.material.opacity=0.8*(1.0-(et/s.lifespan)); s.material.needsUpdate=true; } }

        // --- AI Hint / Demo Logic ---
        // Finds best placement for a given piece shape (Y-Rotation ONLY currently)
        // TODO: Update this function to consider X and Z rotations for AI/Demo
        function findBestPlacementForPiece(pieceShape) {
            if (!pieceShape || !ghostBlocks.length) return null;

            let bestScore = -1; let bestPlacement = null;
            const visibleGhostCoordsMap=new Map(); ghostBlocks.forEach((g,index)=>{if(g.visible){const pos=g.userData.originalPosition; const key=`${pos.x},${pos.y},${pos.z}`; visibleGhostCoordsMap.set(key,{mesh:g,index:index});}});
            if (visibleGhostCoordsMap.size === 0 && !isDemoMode) return null; // Hint needs ghosts
             const needsGhost = !isDemoMode || visibleGhostCoordsMap.size > 0;

            const yAxis=new THREE.Vector3(0,1,0);
            // *** LIMITATION: Only checks Y-axis rotations for now ***
            for(let rot=0;rot<4;rot++){
                const angle=rot*Math.PI/2; const quaternion=new THREE.Quaternion().setFromAxisAngle(yAxis,angle);
                const rotatedShape=pieceShape.map(offset=>{const vec=new THREE.Vector3(offset[0],offset[1],offset[2]).applyQuaternion(quaternion); return [Math.round(vec.x),Math.round(vec.y),Math.round(vec.z)];});
                for(let x=0;x<BOARD_WIDTH;x++){
                    for(let z=0;z<BOARD_DEPTH;z++){
                        let finalY=BOARD_HEIGHT; while(finalY>=0){finalY--; if(!isValidMove(x,finalY,z,rotatedShape)){finalY++; break;}}
                        if(finalY>=BOARD_HEIGHT||!isValidMove(x,finalY,z,rotatedShape))continue;
                        let filledGhostsCount=0; let filledGhostMeshes=[];
                        rotatedShape.forEach(offset=>{const wX=x+offset[0]; const wY=finalY+offset[1]; const wZ=z+offset[2]; const key=`${wX},${wY},${wZ}`; if(visibleGhostCoordsMap.has(key)){filledGhostsCount++; filledGhostMeshes.push(visibleGhostCoordsMap.get(key).mesh);}});

                        if ( (needsGhost && filledGhostsCount > 0) || (!needsGhost && filledGhostsCount === 0) ) {
                             const placementScore=filledGhostsCount*1000-finalY;
                             if(placementScore>bestScore){bestScore=placementScore; bestPlacement={x,y:finalY,z,rotation:angle,shape:rotatedShape,filledMeshes:filledGhostMeshes};}
                        }
                    }
                }
            }
            if (isDemoMode && !bestPlacement && needsGhost) { console.log("Demo/Hint: No ghost-filling spot found."); }
            return bestPlacement;
        }

        function startBlinkingHint(ghostMeshesToBlink) { stopBlinkingHint(); if (!ghostMeshesToBlink || ghostMeshesToBlink.length === 0) return; isBlinkingHint = true; blinkingGhostsInfo = ghostMeshesToBlink.map(mesh => ({ mesh: mesh, originalOpacity: mesh.userData.baseOpacity || 0.25 })); let blinkOn = false; blinkIntervalId = setInterval(() => { blinkOn = !blinkOn; blinkingGhostsInfo.forEach(info => { if (info.mesh && info.mesh.material) { info.mesh.material.opacity = blinkOn ? 0.8 : info.originalOpacity * 0.5; info.mesh.material.emissive.setHex(blinkOn ? 0xffffff : 0x000000); info.mesh.material.needsUpdate = true; } }); }, HINT_BLINK_INTERVAL); setTimeout(stopBlinkingHint, HINT_BLINK_DURATION); }
        function stopBlinkingHint() { if (blinkIntervalId) { clearInterval(blinkIntervalId); blinkIntervalId = null; } blinkingGhostsInfo.forEach(info => { if (info.mesh && info.mesh.material) { info.mesh.material.opacity = info.originalOpacity; info.mesh.material.emissive.setHex(0x000000); info.mesh.material.needsUpdate = true; } }); blinkingGhostsInfo = []; isBlinkingHint = false; }
        function useAiHint() { if (isGameOver || isPaused || !gameStarted || !nextPieceData || aiHintUsesLeft <= 0 || placedTargetBlocks < AI_HINT_ACTIVATE_THRESHOLD) { console.log("AI Hint conditions not met."); updateUI(); return; } console.log("Attempting AI Hint..."); const placement = findBestPlacementForPiece(nextPieceData.shape); /* Analyze NEXT piece */ if (placement && placement.filledMeshes.length > 0) { aiHintUsesLeft--; totalScore -= AI_HINT_COST; console.log(`AI Hint used. Uses left: ${aiHintUsesLeft}. Score: ${totalScore}`); startBlinkingHint(placement.filledMeshes); showMessage("Hint Activated!", HINT_BLINK_DURATION); } else { console.log("AI Hint couldn't find a useful placement for the next piece."); showMessage("AI Hint: No spot found!", 1500); } updateUI(); }

        // --- Demo Mode Logic ---
        function runDemoStep() {
            if (!isDemoMode || isGameOver || !currentPiece) { if (isDemoMode) goToMainMenu(); return; } // Stop demo if conditions change

            // console.log("DEBUG: Running Demo Step..."); // DEBUG
            const placement = findBestPlacementForPiece(currentPiece.shape); // Find placement for CURRENT piece

            if (placement) {
                 // console.log("DEBUG: Demo found placement:", placement); // DEBUG
                 // Instantly move and lock
                 currentPiece.mesh.rotation.set(0, placement.rotation, 0); // Demo only uses Y rotation from findBestPlacement
                 currentPiece.mesh.position.set(placement.x * CUBE_SIZE, placement.y * CUBE_SIZE, placement.z * CUBE_SIZE);
                 currentPiece.x = placement.x; currentPiece.y = placement.y; currentPiece.z = placement.z;
                 currentPiece.shape = placement.shape; currentPiece.rotationY = placement.rotation;

                 lockPiece(); // Lock it (handles score=0 in demo, checks completion which might end demo)

                 // If game didn't end during lock/completion check, schedule next step
                 if (!isGameOver && isDemoMode) { // Check isDemoMode again in case completion ended it
                    // console.log("DEBUG: Demo scheduling next step after lock."); // DEBUG
                    spawnPiece(); // Spawn next piece immediately for demo logic
                    if (currentPiece) { // Ensure a piece actually spawned
                        demoTimeoutId = setTimeout(runDemoStep, DEMO_STEP_DELAY);
                    } else if (!isGameOver) {
                         console.log("Demo: No more pieces to spawn or game over after spawn.");
                         goToMainMenu(); // End demo if no piece spawns
                    }
                 } else if (isGameOver) {
                     console.log("Demo detected game over after lock.");
                 }
            } else {
                 // No valid placement found for the current piece. Skip it.
                 console.log("Demo: Could not find placement for current piece, skipping.");
                 if (currentPiece && currentPiece.mesh.parent) {
                     scene.remove(currentPiece.mesh); // Remove the piece visually
                 }
                 currentPiece = null; // Clear the piece reference

                 // Spawn the next piece and schedule the next step
                 spawnPiece();
                 if (currentPiece && !isGameOver) {
                     demoTimeoutId = setTimeout(runDemoStep, DEMO_STEP_DELAY / 2); // Faster skip
                 } else {
                     console.log("Demo: Ending after skip because no piece spawned or game over.");
                     goToMainMenu();
                 }
            }
        }


        // --- Event Handlers --- (WASD + QE/ZC Controls + Tab)
        function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function onKeyDown(e){
            if(e.key==='r'||e.key==='R'){ goToMainMenu(); return; }
            if(!gameStarted || isDemoMode) return; // Ignore most keys if game not started or in demo

            if(e.key==='p'||e.key==='P'){togglePause();return;}
            if(e.key==='h'||e.key==='H'){useAiHint(); return;}

            if(isGameOver||isPaused||!currentPiece)return;

            if (['a', 'A', 'd', 'D', 'w', 'W', 's', 'S', ' ', 'q', 'Q', 'e', 'E', 'z', 'Z', 'c', 'C', 'ArrowDown', 'Tab'].includes(e.key)) {
                stopBlinkingHint();
            }

            switch(e.key){
                case 'a': case 'A': movePiece(-1,0,0, true); break;
                case 'd': case 'D': movePiece(1,0,0, true); break;
                case 'w': case 'W': movePiece(0,0,-1, true); break;
                case 's': case 'S': movePiece(0,0,1, true); break;
                case ' ': rotatePieceY(); break;
                case 'q': case 'Q': rotatePieceX(false); break;
                case 'e': case 'E': rotatePieceX(true); break;
                case 'z': case 'Z': rotatePieceZ(false); break;
                case 'c': case 'C': rotatePieceZ(true); break;
                case 'ArrowDown': if(currentFallSpeed!==FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_FAST;resetFallTimer();}movePiece(0,-1,0);break;
                case 'Tab':
                    e.preventDefault(); // Prevent default browser tab behavior
                    hardDrop();
                    break;
            }
        }
        function onKeyUp(e){ if(!gameStarted || isGameOver||isPaused||isDemoMode)return; if(e.key==='ArrowDown'){if(currentFallSpeed===FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_NORMAL;resetFallTimer();}} }

        // --- Hard Drop ---
        function hardDrop() {
            if (!currentPiece || isPaused || isGameOver || !gameStarted || isDemoMode) return;

            stopBlinkingHint();
            stopGameLoop(); // Stop normal falling

            let finalY = currentPiece.y;
            while (isValidMove(currentPiece.x, finalY - 1, currentPiece.z, currentPiece.shape)) {
                finalY--;
            }

            if (finalY < currentPiece.y) {
                currentPiece.y = finalY;
                currentPiece.mesh.position.y = finalY * CUBE_SIZE;
                // Play hard drop sound
                if (audioReady && synthHardDrop) {
                    synthHardDrop.triggerAttackRelease("C3", "8n", Tone.now());
                }
            }

            lockPiece(); // Lock the piece immediately

            // Spawn next piece and restart timer if applicable
            if (!isGameOver) {
                spawnPiece();
                if (currentPiece && !isGameOver && !isDemoMode) { // Check again after spawn, only restart timer if not demo
                    resetFallTimer();
                }
            }
        }


        // --- Animation Loop --- (Unchanged)
        function animate() { requestAnimationFrame(animate); const dt=clock.getDelta(); controls.update(); if(gameStarted && !isPaused && !isDemoMode){updateParticles(dt);} renderer.render(scene,camera); if(previewRenderer&&previewScene&&previewCamera){ if(previewPieceMesh && gameStarted && !isPaused){previewPieceMesh.rotation.y+=0.01;} previewRenderer.render(previewScene,previewCamera); } }

        // --- Start the game ---
        init(); // Call init, game waits for user action via welcome/menu screens

    </script>
</body>
</html>
