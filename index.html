<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tetris Builder</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp,container-queries"></script>
    <style>
        :root { /* Define CSS Variables for UI Theming */
            --panel-bg: rgba(50, 50, 50, 0.85);
            --panel-border: rgba(100, 116, 139, 0.7); /* slate-500 */
            --text-color: #e5e7eb; /* gray-200 */
            --text-color-muted: #9ca3af; /* gray-400 */
            --text-color-heading: #f3f4f6; /* gray-100 */
            --button-bg: #4b5563; /* gray-600 */
            --button-border: #6b7280; /* gray-500 */
            --button-hover-bg: #374151; /* gray-700 */
            --button-active-bg: #1f2937; /* gray-800 */
            --accent-color: #3b82f6; /* blue-500 */
        }

        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #111827; /* Darker base bg */ }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        #canvas { display: block; }
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 1rem; color: var(--text-color); pointer-events: none;
        }
        .ui-panel { /* Common style for UI boxes */
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 0.75rem 1rem; /* Increased padding */
            border-radius: 0.75rem; /* More rounded (lg) */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1); /* Enhanced shadow */
            pointer-events: auto; width: fit-content; margin-bottom: 0.75rem; /* Increased margin */
            position: absolute; /* Keep absolute for now, manage layout via containers */
            transition: background-color 0.3s ease, border-color 0.3s ease; /* Smooth transitions */
        }

        /* --- Panel Positions --- */
        #mission-info {
            line-height: 1.5; /* Better spacing */
            top: 1rem; left: 1rem;
        }
        #controls-info { /* Stays bottom-left */
            bottom: 1rem; left: 1rem; font-size: 0.85rem; /* Slightly smaller */
        }
        .ui-controls { /* Top-right buttons container */
           pointer-events: auto; display: flex; gap: 0.5rem;
           position: absolute; top: 1rem; right: 1rem;
        }
        /* Container for Right-Side Panels */
        #right-column {
            position: absolute;
            top: calc(1rem + 40px + 0.5rem); /* Below top buttons */
            right: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Align panels to the right */
            gap: 0.75rem; /* Space between panels */
            pointer-events: none; /* Allow clicks through container */
            width: 224px; /* Fixed width for the column (w-56) */
        }
        /* Make panels inside the right column fill the container */
        #right-column .ui-panel {
            position: static; /* Let flexbox handle positioning */
            width: 100%; /* Make panels fill the container width */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

         #preview-box { text-align: center; }
         #theme-selector {
             /* Use Grid for theme buttons */
             display: grid;
             grid-template-columns: repeat(3, 1fr); /* Create 3 equal columns */
             gap: 0.5rem; /* Space between buttons */
             padding: 0.75rem; /* Adjust padding */
         }
         #lighting-controls { font-size: 0.8rem; padding: 0.75rem; }
         /* --- End Panel Positions --- */


         /* Headings and Text */
         .ui-panel h2 { /* Mission Name */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: var(--text-color-heading);
            margin-bottom: 0.25rem;
         }
          .ui-panel h3 { /* Panel Titles (Next, Theme, Lighting) */
             width: 100%; margin-bottom: 0.75rem; font-weight: 600;
             font-size: 0.9rem; color: var(--text-color-muted); text-align: left;
             border-bottom: 1px solid var(--panel-border); /* Add separator */
             padding-bottom: 0.25rem;
         }
         #score-display { font-weight: 700; font-size: 1.1em; color: #facc15; } /* Yellow score */

         /* Buttons */
         .game-button {
             padding: 0.5rem 1rem; border-radius: 0.5rem; /* md */
             background-color: var(--button-bg); color: var(--text-color-heading); font-weight: 600;
             border: 1px solid var(--button-border); height: 40px;
             box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); /* shadow-md */
             transition: all 0.15s ease-out; cursor: pointer;
             display: inline-flex; /* Align text vertically */
             align-items: center;
             justify-content: center;
         }
         .game-button:hover { background-color: var(--button-hover-bg); transform: translateY(-1px); box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); } /* shadow-lg */
         .game-button:active { background-color: var(--button-active-bg); transform: scale(0.98); }

         .theme-button {
             padding: 0.3rem 0.6rem; font-size: 0.8rem; border-radius: 0.375rem;
             background-color: #5a6578; color: white;
             transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; cursor: pointer;
             border: 1px solid #718096;
             text-align: center; /* Center text in grid cell */
             width: 100%; /* Make button fill grid cell */
         }
         .theme-button:hover { background-color: #3d4758; }
         .theme-button.active { background-color: var(--accent-color); border-color: var(--accent-color); font-weight: 600; }

        /* Lighting Controls Styling */
         #lighting-controls label {
             display: block; margin-bottom: 0.1rem; color: var(--text-color-muted); font-size: 0.75rem;
         }
         #lighting-controls div { /* Add spacing between controls */
             margin-bottom: 0.5rem;
             display: flex; /* Align label, slider, value */
             align-items: center;
             justify-content: space-between;
         }
         #lighting-controls label { flex-basis: 40%; flex-shrink: 0; } /* Give label fixed space */
         #lighting-controls input[type="range"] {
             flex-grow: 1; /* Allow slider to take remaining space */
             width: auto; /* Override fixed width */
             height: 5px;
             cursor: pointer;
             accent-color: var(--accent-color); /* Color the slider track/thumb */
             margin: 0 0.5rem; /* Add horizontal margin */
         }
         #lighting-controls span { /* For displaying slider value */
             display: inline-block;
             min-width: 2.5em; /* Ensure space for value */
             text-align: right;
             color: var(--text-color-heading);
             font-size: 0.75rem;
         }


         #preview-canvas { width: 80px; height: 80px; border-radius: 0.375rem; background-color: rgba(0, 0, 0, 0.2); margin: 0 auto; /* Center canvas */ }

         #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 1.5rem 2.5rem; border-radius: 0.75rem; font-size: 1.75rem; text-align: center; display: none; z-index: 10; pointer-events: none; }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="ui-overlay">
            <div id="mission-info" class="ui-panel">
                <h2>Mission: <span id="mission-name">Loading...</span></h2>
                <p>Blocks Placed: <span id="blocks-placed">0</span> / <span id="blocks-target">0</span></p>
                <p>Score: <span id="score-display">0</span></p>
            </div>

            <div class="ui-controls">
                 <button id="pause-button" class="game-button">Pause</button>
                 <button id="restart-button" class="game-button">Restart Mission</button>
            </div>

            <div id="right-column">
                 <div id="preview-box" class="ui-panel">
                     <h3>Next Block</h3>
                     <canvas id="preview-canvas"></canvas>
                 </div>
                 <div id="theme-selector" class="ui-panel">
                     <h3>Theme</h3>
                     <button class="theme-button" data-theme="default">Default</button>
                     <button class="theme-button" data-theme="milkyway">Stars</button>
                     <button class="theme-button" data-theme="cyberpunk">Cyber</button>
                     <button class="theme-button" data-theme="jungle">Jungle</button>
                     <button class="theme-button" data-theme="town">Town</button>
                 </div>
                 <div id="lighting-controls" class="ui-panel">
                     <h3>Lighting</h3>
                     <div>
                         <label for="hemi-intensity">Hemi:</label>
                         <input type="range" id="hemi-intensity" name="hemi-intensity" min="0" max="3" step="0.1">
                         <span id="hemi-intensity-value">1.0</span>
                     </div>
                     <div>
                         <label for="ambient-intensity">Ambient:</label>
                         <input type="range" id="ambient-intensity" name="ambient-intensity" min="0" max="2" step="0.1">
                         <span id="ambient-intensity-value">1.0</span>
                     </div>
                     <div>
                         <label for="dir-intensity">Sun Int:</label>
                         <input type="range" id="dir-intensity" name="dir-intensity" min="0" max="5" step="0.1">
                         <span id="dir-intensity-value">1.0</span>
                     </div>
                     <div>
                         <label for="dir-y">Sun Angle:</label>
                         <input type="range" id="dir-y" name="dir-y" min="1" max="30" step="1">
                         <span id="dir-y-value">15</span>
                     </div>
                 </div>
            </div>


            <div id="controls-info" class="ui-panel">
                <strong>Controls:</strong> Arrow Keys (Move X/Z), W/S (Move Z), Up Arrow (Rotate Y), P (Pause/Resume), R (Restart)
            </div>

        </div>
        <div id="message-box">Message</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        const BOARD_WIDTH = 10; const BOARD_HEIGHT = 20; const BOARD_DEPTH = 10;
        const CUBE_SIZE = 1; const FALL_SPEED_NORMAL = 1000; const FALL_SPEED_FAST = 50;
        const LOCK_FLASH_DURATION = 250; const PARTICLE_COUNT = 50; const PARTICLE_LIFESPAN = 0.5;
        const PREVIEW_CANVAS_SIZE = 80;
        const POINTS_PER_CUBE = 10; const POINTS_PER_CORRECT_CUBE_BONUS = 50; const POINTS_MISSION_COMPLETE = 500;
        const MAX_TIME_BONUS = 1000; const MAX_TIME_ALLOWED_PER_MISSION = 120;
        const STARFIELD_RADIUS = 200; const STARFIELD_COUNT = 5000;

        // --- Game State ---
        let scene, camera, renderer, controls, clock;
        let board = []; let currentPiece = null; let ghostBlocks = [];
        let lockedBlocksGroup = new THREE.Group(); let currentMissionIndex = 0;
        let fallInterval; let currentFallSpeed = FALL_SPEED_NORMAL;
        let targetBlockCount = 0; let placedTargetBlocks = 0;
        let isGameOver = false; let isPaused = false; let activeParticles = [];
        let nextPieceData = null; let totalScore = 0; let missionStartTime = 0;

        // --- Scene Elements (for theme changes) ---
        let hemisphereLight, ambientLight, directionalLight, groundPlane;
        let starfield = null;

        // --- Preview Scene State ---
        let previewScene, previewCamera, previewRenderer, previewPieceMesh = null;

        // DOM Elements
        let pauseButton, restartButton, messageBox, previewCanvas, scoreDisplay, themeButtons;
        let hemiIntensitySlider, ambientIntensitySlider, dirIntensitySlider, dirYSlider;
        let hemiIntensityValueSpan, ambientIntensityValueSpan, dirIntensityValueSpan, dirYValueSpan;


        // --- Loaders ---
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();

        // --- Textures ---
        let groundTexture = null;

        // --- Helper Function for Placeholder Skybox URLs ---
        function createPlaceholderSkybox(bC,tC,p=''){const s=256; return [`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NX`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NY`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}PZ`,`https://placehold.co/${s}x${s}/${bC}/${tC}?text=${p}NZ`];}

        // --- Theme Definitions (with UI colors) ---
        const themes = {
            default: {
                background: new THREE.Color(0x333340), skybox: null, starfield: false,
                fog: { color: 0x333340, near: BOARD_DEPTH * 1.5, far: BOARD_DEPTH * 3 },
                lights: { hemiSky: 0xadcafc, hemiGround: 0x404040, hemiIntensity: 1.5, ambient: 0xffffff, ambientIntensity: 0.3, dir: 0xffffff, dirIntensity: 2.0, dirY: 15 },
                groundColor: 0xaaaaaa,
                ui: { panelBg: 'rgba(50, 50, 64, 0.85)', panelBorder: 'rgba(100, 116, 139, 0.7)', textColor: '#e5e7eb', textColorMuted: '#9ca3af', textColorHeading: '#f3f4f6', accent: '#60a5fa' } // Blueish gray UI
            },
            milkyway: {
                background: new THREE.Color(0x000005), skybox: null, starfield: true, fog: null,
                lights: { hemiSky: 0x303050, hemiGround: 0x101020, hemiIntensity: 0.5, ambient: 0x404060, ambientIntensity: 0.15, dir: 0xaaaaff, dirIntensity: 0.8, dirY: 10 },
                groundColor: 0x222222,
                ui: { panelBg: 'rgba(10, 10, 20, 0.85)', panelBorder: 'rgba(70, 70, 100, 0.7)', textColor: '#a0a0c0', textColorMuted: '#707090', textColorHeading: '#c0c0e0', accent: '#aaaaff' } // Dark blue/purple UI
            },
            cyberpunk: {
                background: new THREE.Color(0x1a0a2a), skybox: createPlaceholderSkybox('1a0a2a', 'FF00FF', 'CYBER_'), starfield: false,
                fog: { color: 0xff00ff, near: BOARD_DEPTH * 1.2, far: BOARD_DEPTH * 2.8 },
                lights: { hemiSky: 0x00aaff, hemiGround: 0xff00aa, hemiIntensity: 1.8, ambient: 0x8888ff, ambientIntensity: 0.4, dir: 0x00ffff, dirIntensity: 1.8, dirY: 20 },
                groundColor: 0x440044,
                ui: { panelBg: 'rgba(40, 10, 60, 0.9)', panelBorder: 'rgba(255, 0, 255, 0.5)', textColor: '#f0f', textColorMuted: '#a0a', textColorHeading: '#fff0ff', accent: '#0ff' } // Neon magenta/cyan UI
            },
            jungle: {
                background: new THREE.Color(0x305020), skybox: createPlaceholderSkybox('305020', 'b0d0a0', 'JUNGLE_'), starfield: false,
                fog: { color: 0x305020, near: BOARD_DEPTH * 0.7, far: BOARD_DEPTH * 2.2 },
                lights: { hemiSky: 0xb0d0a0, hemiGround: 0x406030, hemiIntensity: 1.2, ambient: 0xeeeecc, ambientIntensity: 0.6, dir: 0xffffcc, dirIntensity: 1.5, dirY: 12 },
                groundColor: 0x556B2F,
                ui: { panelBg: 'rgba(48, 80, 32, 0.9)', panelBorder: 'rgba(85, 107, 47, 0.7)', textColor: '#d0e0c0', textColorMuted: '#80a070', textColorHeading: '#f0fff0', accent: '#90ee90' } // Earthy green UI
            },
            town: {
                background: new THREE.Color(0x87CEEB), skybox: createPlaceholderSkybox('87CEEB', 'FFFFFF', 'TOWN_'), starfield: false,
                fog: { color: 0xcccccc, near: BOARD_DEPTH * 2.0, far: BOARD_DEPTH * 4.0 },
                lights: { hemiSky: 0xffffff, hemiGround: 0xaaaaaa, hemiIntensity: 1.8, ambient: 0xffffff, ambientIntensity: 0.6, dir: 0xffffee, dirIntensity: 2.2, dirY: 18 },
                groundColor: 0xbbbbbb,
                ui: { panelBg: 'rgba(220, 220, 220, 0.85)', panelBorder: 'rgba(180, 180, 180, 0.7)', textColor: '#444', textColorMuted: '#777', textColorHeading: '#222', accent: '#4299e1' } // Light gray/blue UI
            }
        };
        let currentTheme = 'default';

        // --- Mission Definitions --- (Shortened)
        const missions = [ { name: "1", d:{x:4,y:1,z:4}, b: generateSolidBlueprint(4,1,4) }, { name: "2", d:{x:4,y:1,z:4}, b: generateWallBlueprint(4,1,4) }, { name: "3", d:{x:1,y:5,z:1}, b: generateSolidBlueprint(1,5,1) }, { name: "4", d:{x:4,y:2,z:4}, b: generateHollowBlueprint(4,2,4) }, { name: "5", d:{x:5,y:3,z:1}, b: generateArchBlueprint(5,3,1) } ];
        // --- Tetromino Definitions --- (Shortened)
        const TETROMINOES = {'I':{c:0x00FFFF,s:[[0,0,0],[-1,0,0],[1,0,0],[2,0,0]]},'O':{c:0xFFFF00,s:[[0,0,0],[1,0,0],[0,1,0],[1,1,0]]},'T':{c:0x800080,s:[[0,0,0],[-1,0,0],[1,0,0],[0,1,0]]},'L':{c:0xFFA500,s:[[0,0,0],[-1,0,0],[1,0,0],[1,1,0]]},'J':{c:0x0000FF,s:[[0,0,0],[-1,0,0],[1,0,0],[-1,1,0]]},'S':{c:0x00FF00,s:[[0,0,0],[-1,0,0],[0,1,0],[1,1,0]]},'Z':{c:0xFF0000,s:[[0,0,0],[1,0,0],[0,1,0],[-1,1,0]]}}; const TETROMINO_KEYS = Object.keys(TETROMINOES);
        // --- Blueprint Generation Helpers --- (Shortened)
        function getBlueprintOffset(w,d){ return {x:Math.floor((BOARD_WIDTH-w)/2), z:Math.floor((BOARD_DEPTH-d)/2)}; } function generateSolidBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateWallBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) if(x===0||x===w-1||z===0||z===d-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateHollowBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); for(let y=0;y<h;y++) for(let x=0;x<w;x++) for(let z=0;z<d;z++) if(x===0||x===w-1||z===0||z===d-1) b.push({x:x+o.x,y:y,z:z+o.z}); return b; } function generateArchBlueprint(w,h,d){ const b=[]; const o=getBlueprintOffset(w,d); const ph=h-1; const sy=ph; if(w<3) return generateSolidBlueprint(w,h,d); for(let y=0;y<ph;y++){ for(let z=0;z<d;z++) b.push({x:o.x,y:y,z:z+o.z}); for(let z=0;z<d;z++) b.push({x:o.x+w-1,y:y,z:z+o.z}); } for(let x=0;x<w;x++) for(let z=0;z<d;z++) b.push({x:x+o.x,y:sy,z:z+o.z}); return b; }

        // --- Initialization ---
        function init() {
            clock = new THREE.Clock();
            // Get UI Elements
            pauseButton = document.getElementById('pause-button'); restartButton = document.getElementById('restart-button'); messageBox = document.getElementById('message-box');
            previewCanvas = document.getElementById('preview-canvas'); scoreDisplay = document.getElementById('score-display');
            themeButtons = document.querySelectorAll('.theme-button');
            // Lighting Control Elements
            hemiIntensitySlider = document.getElementById('hemi-intensity'); ambientIntensitySlider = document.getElementById('ambient-intensity');
            dirIntensitySlider = document.getElementById('dir-intensity'); dirYSlider = document.getElementById('dir-y');
            hemiIntensityValueSpan = document.getElementById('hemi-intensity-value'); ambientIntensityValueSpan = document.getElementById('ambient-intensity-value');
            dirIntensityValueSpan = document.getElementById('dir-intensity-value'); dirYValueSpan = document.getElementById('dir-y-value');


            // --- Main Scene Setup ---
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(BOARD_WIDTH/2, BOARD_HEIGHT*0.8, BOARD_DEPTH*1.6); camera.lookAt(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0;

            // --- Create Lights ---
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.0); scene.add(hemisphereLight);
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(8, 15, 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50; const shadowCamSize = Math.max(BOARD_WIDTH, BOARD_DEPTH)*0.8; directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize; directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize; directionalLight.shadow.bias = -0.0005; scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement); controls.target.set(BOARD_WIDTH/2, BOARD_HEIGHT/3, BOARD_DEPTH/2); controls.enablePan = true; controls.maxPolarAngle = Math.PI/2 - 0.05; controls.minDistance = 5; controls.maxDistance = 50; controls.enableDamping = true; controls.dampingFactor = 0.05; controls.update();
            loadTextures(); createBoardVisuals();
            lockedBlocksGroup.castShadow = true; lockedBlocksGroup.receiveShadow = true; scene.add(lockedBlocksGroup);
            initBoard(); initPreviewRenderer();

            // --- Apply Default Theme ---
            applyTheme('default'); // Also sets initial slider values

            // --- Start Game ---
            totalScore = 0; nextPieceData = determineNextPiece();
            loadMission(currentMissionIndex);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            pauseButton.addEventListener('click', togglePause); restartButton.addEventListener('click', restartMission);
            themeButtons.forEach(button => { button.addEventListener('click', () => { applyTheme(button.dataset.theme); }); });

            // Lighting Control Listeners
            hemiIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); hemisphereLight.intensity=v; hemiIntensityValueSpan.textContent=v.toFixed(1); });
            ambientIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); ambientLight.intensity=v; ambientIntensityValueSpan.textContent=v.toFixed(1); });
            dirIntensitySlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.intensity=v; dirIntensityValueSpan.textContent=v.toFixed(1); });
            dirYSlider.addEventListener('input', (e) => { const v=parseFloat(e.target.value); directionalLight.position.y=v; dirYValueSpan.textContent=v.toFixed(0); });

            animate();
        }

        function initPreviewRenderer() { /* ... same as before ... */ previewScene=new THREE.Scene(); previewScene.background=null; const a=PREVIEW_CANVAS_SIZE/PREVIEW_CANVAS_SIZE; const fS=4*CUBE_SIZE; previewCamera=new THREE.OrthographicCamera(fS*a/-2,fS*a/2,fS/2,fS/-2,0.1,100); previewCamera.position.set(0,0,5); previewCamera.lookAt(0,0,0); previewRenderer=new THREE.WebGLRenderer({canvas:previewCanvas,antialias:true,alpha:true}); previewRenderer.setSize(PREVIEW_CANVAS_SIZE,PREVIEW_CANVAS_SIZE); previewRenderer.setPixelRatio(window.devicePixelRatio); previewRenderer.toneMapping=THREE.ACESFilmicToneMapping; previewRenderer.toneMappingExposure=1.0; const pA=new THREE.AmbientLight(0xffffff,1.0); previewScene.add(pA); const pL=new THREE.DirectionalLight(0xffffff,1.5); pL.position.set(1,2,3); previewScene.add(pL); }
        function loadTextures() { /* ... same as before ... */ const gTU=`https://placehold.co/64x64/cccccc/999999.png?text=+`; groundTexture=textureLoader.load(gTU,(t)=>{t.wrapS=THREE.RepeatWrapping; t.wrapT=THREE.RepeatWrapping; t.repeat.set(BOARD_WIDTH,BOARD_DEPTH); console.log("GT loaded."); groundPlane=scene.getObjectByName("groundPlane"); if(groundPlane){groundPlane.material.map=t; groundPlane.material.needsUpdate=true;}},undefined,(e)=>{console.error('Error loading GT:',e);}); }
        function initBoard() { /* ... same as before ... */ board=Array(BOARD_WIDTH).fill(null).map(()=>Array(BOARD_HEIGHT).fill(null).map(()=>Array(BOARD_DEPTH).fill(0))); }
        function createBoardVisuals() { /* ... same as before ... */ const gH=new THREE.GridHelper(Math.max(BOARD_WIDTH,BOARD_DEPTH),Math.max(BOARD_WIDTH,BOARD_DEPTH),0x888888,0x444444); gH.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2+0.01,BOARD_DEPTH/2-CUBE_SIZE/2); scene.add(gH); const gG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_DEPTH*CUBE_SIZE); const gM=new THREE.MeshStandardMaterial({color:0xaaaaaa,map:groundTexture,side:THREE.DoubleSide,roughness:0.8,metalness:0.2}); groundPlane=new THREE.Mesh(gG,gM); groundPlane.name="groundPlane"; groundPlane.rotation.x=-Math.PI/2; groundPlane.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); groundPlane.receiveShadow=true; scene.add(groundPlane); const wM=new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.05,side:THREE.DoubleSide}); const bWG=new THREE.PlaneGeometry(BOARD_WIDTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const bW=new THREE.Mesh(bWG,wM); bW.position.set(BOARD_WIDTH/2-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,-CUBE_SIZE/2); scene.add(bW); const lWG=new THREE.PlaneGeometry(BOARD_DEPTH*CUBE_SIZE,BOARD_HEIGHT*CUBE_SIZE); const lW=new THREE.Mesh(lWG,wM); lW.position.set(-CUBE_SIZE/2,BOARD_HEIGHT/2-CUBE_SIZE/2,BOARD_DEPTH/2-CUBE_SIZE/2); lW.rotation.y=Math.PI/2; scene.add(lW); const rW=lW.clone(); rW.position.x=BOARD_WIDTH-CUBE_SIZE/2; scene.add(rW); }

        // --- Starfield ---
        function createStarfield(){ if(starfield)removeStarfield(); const v=[]; for(let i=0;i<STARFIELD_COUNT;i++){ const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const r=STARFIELD_RADIUS*Math.cbrt(Math.random()); const x=r*Math.sin(ph)*Math.cos(th); const y=r*Math.sin(ph)*Math.sin(th); const z=r*Math.cos(ph); v.push(x,y,z); } const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); const m=new THREE.PointsMaterial({color:0xffffff,size:0.15,sizeAttenuation:true,transparent:true,opacity:0.8}); starfield=new THREE.Points(g,m); starfield.name="starfield"; scene.add(starfield); console.log("Starfield created."); }
        function removeStarfield(){ if(starfield){ scene.remove(starfield); starfield.geometry.dispose(); starfield.material.dispose(); starfield=null; console.log("Starfield removed."); } }

        // --- Theme Application ---
        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) { console.warn(`Theme "${themeName}" not found.`); return; }
            console.log(`Applying theme: ${themeName}`);
            currentTheme = themeName;

            // Cleanup previous
            removeStarfield();
            if (scene.background && scene.background.isTexture) { scene.background = null; }

            // Apply new Background/Starfield
            if (theme.starfield) {
                scene.background = theme.background; createStarfield();
            } else if (theme.skybox && theme.skybox.length === 6) {
                scene.background = theme.background; // Fallback
                cubeTextureLoader.load( theme.skybox, (t) => { scene.background = t; console.log(`${themeName} skybox loaded.`); }, undefined, (e) => { console.error(`Skybox error ${themeName}:`, e); scene.background = theme.background; } );
            } else { scene.background = theme.background; }

            // Update Fog
            if (theme.fog) { if (!scene.fog) { scene.fog = new THREE.Fog(theme.fog.color, theme.fog.near, theme.fog.far); } else { scene.fog.color.set(theme.fog.color); scene.fog.near = theme.fog.near; scene.fog.far = theme.fog.far; } } else { scene.fog = null; }

            // Update Lights & Controls
            if (theme.lights) {
                hemisphereLight.color.setHex(theme.lights.hemiSky); hemisphereLight.groundColor.setHex(theme.lights.hemiGround); hemisphereLight.intensity = theme.lights.hemiIntensity;
                ambientLight.color.setHex(theme.lights.ambient); ambientLight.intensity = theme.lights.ambientIntensity;
                directionalLight.color.setHex(theme.lights.dir); directionalLight.intensity = theme.lights.dirIntensity;
                directionalLight.position.y = theme.lights.dirY;

                // Update sliders to match theme
                hemiIntensitySlider.value = theme.lights.hemiIntensity; hemiIntensityValueSpan.textContent = theme.lights.hemiIntensity.toFixed(1);
                ambientIntensitySlider.value = theme.lights.ambientIntensity; ambientIntensityValueSpan.textContent = theme.lights.ambientIntensity.toFixed(1);
                dirIntensitySlider.value = theme.lights.dirIntensity; dirIntensityValueSpan.textContent = theme.lights.dirIntensity.toFixed(1);
                dirYSlider.value = theme.lights.dirY; dirYValueSpan.textContent = theme.lights.dirY.toFixed(0);
            }

            // Update Ground
            if (groundPlane && groundPlane.material) { groundPlane.material.color.setHex(theme.groundColor); groundPlane.material.needsUpdate = true; }

            // --- Update UI Theme via CSS Variables ---
            const rootStyle = document.documentElement.style;
            if(theme.ui) {
                rootStyle.setProperty('--panel-bg', theme.ui.panelBg);
                rootStyle.setProperty('--panel-border', theme.ui.panelBorder);
                rootStyle.setProperty('--text-color', theme.ui.textColor);
                rootStyle.setProperty('--text-color-muted', theme.ui.textColorMuted);
                rootStyle.setProperty('--text-color-heading', theme.ui.textColorHeading);
                rootStyle.setProperty('--accent-color', theme.ui.accent);
                // Add button colors if defined in theme.ui
                rootStyle.setProperty('--button-bg', theme.ui.buttonBg || '#4b5563');
                rootStyle.setProperty('--button-border', theme.ui.buttonBorder || '#6b7280');
                rootStyle.setProperty('--button-hover-bg', theme.ui.buttonHoverBg || '#374151');
            }
            // ---

            // Update active theme button style
            themeButtons.forEach(button => { button.classList.toggle('active', button.dataset.theme === themeName); });
        }


        // --- Mission Handling --- (Unchanged)
        function loadMission(mI, isR=false){ if(fallInterval)clearInterval(fallInterval); fallInterval=null; if(!isR&&mI>=missions.length){showMessage(`All Missions Complete! Final Score: ${totalScore}`);gameOver(true);return;} if(mI>=missions.length){mI=missions.length-1;} const m=missions[mI]; console.log(`Loading Mission: ${m.name}`); clearBoard(); clearGhostBlocks(); if(currentPiece){scene.remove(currentPiece.mesh);currentPiece=null;} placedTargetBlocks=0; targetBlockCount=m.b.length; displayBlueprint(m.b); document.getElementById('mission-name').textContent=m.name; isGameOver=false; isPaused=false; pauseButton.textContent='Pause'; hideMessage(); missionStartTime=clock.getElapsedTime(); updateUI(); if(!isR||!nextPieceData){nextPieceData=determineNextPiece();} updatePreview(nextPieceData); spawnPiece(); if(currentPiece&&!isGameOver){currentFallSpeed=FALL_SPEED_NORMAL;startGameLoop();}else if(isGameOver){console.log("GO on load.");} }
        function displayBlueprint(b){ const gm=new THREE.MeshStandardMaterial({color:0xaaaaaa,transparent:true,opacity:0.25,roughness:0.9}); const gg=new THREE.BoxGeometry(CUBE_SIZE*0.95,CUBE_SIZE*0.95,CUBE_SIZE*0.95); b.forEach(c=>{ if(c.x<0||c.x>=BOARD_WIDTH||c.y<0||c.y>=BOARD_HEIGHT||c.z<0||c.z>=BOARD_DEPTH){console.warn("BP coord out:",c);return;} const gc=new THREE.Mesh(gg,gm.clone()); gc.position.set(c.x*CUBE_SIZE,c.y*CUBE_SIZE,c.z*CUBE_SIZE); gc.userData.isGhost=true; gc.userData.originalPosition={x:c.x,y:c.y,z:c.z}; scene.add(gc); ghostBlocks.push(gc);}); targetBlockCount=ghostBlocks.length; updateUI();}
        function clearGhostBlocks() { ghostBlocks.forEach(g => { scene.remove(g); }); ghostBlocks = []; }
        function checkMissionCompletion(){ if(isGameOver)return false; if(placedTargetBlocks>=targetBlockCount&&targetBlockCount>0){ const mN=missions[currentMissionIndex].name; let mCB=POINTS_MISSION_COMPLETE; const tT=clock.getElapsedTime()-missionStartTime; const tBR=Math.max(0,1.0-(tT/MAX_TIME_ALLOWED_PER_MISSION)); let tB=Math.round(MAX_TIME_BONUS*tBR); totalScore+=mCB; totalScore+=tB; updateUI(); showMessage(`Mission ${mN} Complete!\nScore +${mCB} +${tB} (Time)`,3500); const cP=new THREE.Vector3(BOARD_WIDTH/2*CUBE_SIZE,0,BOARD_DEPTH/2*CUBE_SIZE); createParticleEffect(cP,0xffd700,150,1.5); currentMissionIndex++; if(fallInterval)clearInterval(fallInterval); fallInterval=null; setTimeout(()=>{loadMission(currentMissionIndex);},3600); return true; } return false; }

        // --- Game Loop & Piece Logic --- (Unchanged)
        function startGameLoop(){ if(isPaused||isGameOver)return; if(fallInterval)clearInterval(fallInterval); fallInterval=setInterval(()=>{if(!isPaused&&!isGameOver&&currentPiece){movePiece(0,-1,0);}},currentFallSpeed); console.log("Timer start/reset:",currentFallSpeed); }
        function stopGameLoop(){ if(fallInterval){clearInterval(fallInterval); fallInterval=null; console.log("Timer stop.");} }
        function resetFallTimer(){ if(!isPaused&&!isGameOver){startGameLoop();} }
        function determineNextPiece(){ const k=TETROMINO_KEYS[Math.floor(Math.random()*TETROMINO_KEYS.length)]; const d=TETROMINOES[k]; return {type:k, color:d.c, shape:JSON.parse(JSON.stringify(d.s))}; }
        function spawnPiece(){ if(isGameOver||isPaused)return; if(!nextPieceData){console.warn("nextPD null."); nextPieceData=determineNextPiece();} const cPD=nextPieceData; nextPieceData=determineNextPiece(); updatePreview(nextPieceData); const sX=Math.floor(BOARD_WIDTH/2); const sY=BOARD_HEIGHT-1; const sZ=Math.floor(BOARD_DEPTH/2); const pG=new THREE.Group(); const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:cPD.color,metalness:0.3,roughness:0.5}); cPD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); c.castShadow=true; c.receiveShadow=false; pG.add(c); }); currentPiece={mesh:pG,shape:cPD.shape,x:sX,y:sY,z:sZ,rotationY:0}; currentPiece.mesh.position.set(sX*CUBE_SIZE,sY*CUBE_SIZE,sZ*CUBE_SIZE); if(!isValidMove(currentPiece.x,currentPiece.y,currentPiece.z,currentPiece.shape)){console.log("GO on spawn!"); gameOver(); currentPiece=null; if(nextPieceData)updatePreview(nextPieceData); return;} scene.add(currentPiece.mesh); console.log("Spawned:",cPD.type,"Next:",nextPieceData.type); }
        function movePiece(dx,dy,dz){ if(!currentPiece||isPaused||isGameOver)return; const nX=currentPiece.x+dx; const nY=currentPiece.y+dy; const nZ=currentPiece.z+dz; if(isValidMove(nX,nY,nZ,currentPiece.shape)){ currentPiece.x=nX; currentPiece.y=nY; currentPiece.z=nZ; currentPiece.mesh.position.set(currentPiece.x*CUBE_SIZE,currentPiece.y*CUBE_SIZE,currentPiece.z*CUBE_SIZE); }else if(dy<0){ lockPiece(); if(!isGameOver){ spawnPiece(); if(currentFallSpeed!==FALL_SPEED_NORMAL){ currentFallSpeed=FALL_SPEED_NORMAL; resetFallTimer(); } } } }
        function rotatePieceY(){ if(!currentPiece||isPaused||isGameOver)return; const ax=new THREE.Vector3(0,1,0); const ang=Math.PI/2; const qu=new THREE.Quaternion().setFromAxisAngle(ax,ang); const rs=currentPiece.shape.map(o=>{ const v=new THREE.Vector3(o[0],o[1],o[2]).applyQuaternion(qu); return [Math.round(v.x),Math.round(v.y),Math.round(v.z)]; }); if(isValidMove(currentPiece.x,currentPiece.y,currentPiece.z,rs)){ currentPiece.mesh.applyQuaternion(qu); currentPiece.shape=rs; currentPiece.rotationY=(currentPiece.rotationY+ang)%(2*Math.PI); console.log("Rotated"); }else{ console.log("Rot blocked"); } }
        function isValidMove(bX,bY,bZ,sh){ for(const o of sh){ const wX=bX+o[0]; const wY=bY+o[1]; const wZ=bZ+o[2]; if(wX<0||wX>=BOARD_WIDTH||wY<0||wZ<0||wZ>=BOARD_DEPTH)return false; if(wY>=BOARD_HEIGHT)continue; if(board[wX][wY][wZ]!==0)return false; } return true; }
        function lockPiece(){ if(!currentPiece||isGameOver)return; console.log("Locking:",currentPiece.x,currentPiece.y,currentPiece.z); let mPM=false; const pM=currentPiece.mesh.children[0].material; let sGTL=0; currentPiece.shape.forEach(o=>{ const wX=currentPiece.x+o[0]; const wY=currentPiece.y+o[1]; const wZ=currentPiece.z+o[2]; if(wX>=0&&wX<BOARD_WIDTH&&wY>=0&&wY<BOARD_HEIGHT&&wZ>=0&&wZ<BOARD_DEPTH){ const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=pM.clone(); const lC=new THREE.Mesh(geo,mat); lC.position.set(wX*CUBE_SIZE,wY*CUBE_SIZE,wZ*CUBE_SIZE); lC.castShadow=true; lC.receiveShadow=true; lockedBlocksGroup.add(lC); board[wX][wY][wZ]=1; totalScore+=POINTS_PER_CUBE; sGTL+=POINTS_PER_CUBE; const fGI=ghostBlocks.findIndex(g=>g.visible&&g.userData.originalPosition.x===wX&&g.userData.originalPosition.y===wY&&g.userData.originalPosition.z===wZ); if(fGI!==-1){ ghostBlocks[fGI].visible=false; placedTargetBlocks++; mPM=true; console.log("BP filled!"); totalScore+=POINTS_PER_CORRECT_CUBE_BONUS; sGTL+=POINTS_PER_CORRECT_CUBE_BONUS; const pP=lC.position.clone(); createParticleEffect(pP,mat.color); const oE=mat.emissive.getHex(); mat.emissive.setHex(0xffffff); mat.needsUpdate=true; setTimeout(()=>{if(lC.parent){mat.emissive.setHex(oE); mat.needsUpdate=true;}},LOCK_FLASH_DURATION); } }else{ console.warn("Lock out:",wX,wY,wZ); if(wY>=BOARD_HEIGHT){console.log("Lock above - GO."); if(currentPiece&&currentPiece.mesh.parent)scene.remove(currentPiece.mesh); currentPiece=null; gameOver(); return;} } }); if(currentPiece&&currentPiece.mesh.parent){scene.remove(currentPiece.mesh);} currentPiece=null; console.log(`Score gain lock: ${sGTL}`); updateUI(); if(!isGameOver&&mPM){checkMissionCompletion();} }
        function clearBoard(){ initBoard(); while(lockedBlocksGroup.children.length>0){ const o=lockedBlocksGroup.children[0]; if(o.geometry)o.geometry.dispose(); if(o.material){if(Array.isArray(o.material))o.material.forEach(m=>m.dispose()); else o.material.dispose();} lockedBlocksGroup.remove(o); } activeParticles.forEach(p=>scene.remove(p.mesh)); activeParticles=[]; removeStarfield(); /* Ensure starfield is cleared on board clear */ }
        function gameOver(isC=false){ console.log("GO. All complete:",isC); isGameOver=true; stopGameLoop(); if(!isC)showMessage(`Game Over! Final Score: ${totalScore}`); }

        // --- UI Functions --- (Unchanged)
        function updateUI(){ document.getElementById('blocks-placed').textContent=placedTargetBlocks; document.getElementById('blocks-target').textContent=targetBlockCount; scoreDisplay.textContent=totalScore; }
        function showMessage(t,d=3000){ messageBox.textContent=t; messageBox.style.display='block'; if(d>0){setTimeout(()=>{if(messageBox.textContent===t)hideMessage();},d);} }
        function hideMessage(){ messageBox.style.display='none'; }
        function togglePause(){ if(isGameOver)return; isPaused=!isPaused; console.log("Paused:",isPaused); if(isPaused){ stopGameLoop(); showMessage("Paused",0); pauseButton.textContent='Resume'; }else{ hideMessage(); pauseButton.textContent='Pause'; if(currentPiece)startGameLoop(); else{ console.log("Resume no piece, spawn."); spawnPiece(); if(currentPiece&&!isGameOver)startGameLoop(); } } }
        function restartMission(){ console.log("Restart mission..."); stopGameLoop(); isGameOver=false; isPaused=false; hideMessage(); pauseButton.textContent='Pause'; loadMission(currentMissionIndex,true); }

        // --- Preview Update --- (Unchanged)
        function updatePreview(pD){ if(!previewScene)return; if(previewPieceMesh){previewScene.remove(previewPieceMesh);} if(!pD)return; const geo=new THREE.BoxGeometry(CUBE_SIZE,CUBE_SIZE,CUBE_SIZE); const mat=new THREE.MeshStandardMaterial({color:pD.color,metalness:0.3,roughness:0.5}); previewPieceMesh=new THREE.Group(); pD.shape.forEach(o=>{ const c=new THREE.Mesh(geo,mat.clone()); c.position.set(o[0]*CUBE_SIZE,o[1]*CUBE_SIZE,o[2]*CUBE_SIZE); previewPieceMesh.add(c); }); const box=new THREE.Box3().setFromObject(previewPieceMesh); const center=box.getCenter(new THREE.Vector3()); previewPieceMesh.position.sub(center); previewScene.add(previewPieceMesh); console.log("Preview:",pD.type); }

        // --- Particle System --- (Unchanged)
        function createParticleEffect(p,c=0xffffff,co=PARTICLE_COUNT,l=PARTICLE_LIFESPAN){ const pg=new THREE.BufferGeometry(); const v=[]; const ve=[]; const st=[]; for(let i=0;i<co;i++){ v.push(0,0,0); const th=Math.random()*Math.PI*2; const ph=Math.acos((Math.random()*2)-1); const sp=1+Math.random()*3; ve.push(Math.sin(ph)*Math.cos(th)*sp,Math.cos(ph)*sp,Math.sin(ph)*Math.sin(th)*sp); st.push(clock.getElapsedTime()); } pg.setAttribute('position',new THREE.Float32BufferAttribute(v,3)); pg.setAttribute('velocity',new THREE.Float32BufferAttribute(ve,3)); pg.setAttribute('startTime',new THREE.Float32BufferAttribute(st,1)); const pm=new THREE.PointsMaterial({color:c,size:0.1,transparent:true,opacity:0.8,sizeAttenuation:true,depthWrite:false,blending:THREE.AdditiveBlending}); const pt=new THREE.Points(pg,pm); pt.position.copy(p); scene.add(pt); activeParticles.push({mesh:pt,geometry:pg,material:pm,startTime:clock.getElapsedTime(),lifespan:l}); }
        function updateParticles(dt){ const ct=clock.getElapsedTime(); for(let i=activeParticles.length-1;i>=0;i--){ const s=activeParticles[i]; const et=ct-s.startTime; if(et>s.lifespan){ scene.remove(s.mesh); s.geometry.dispose(); s.material.dispose(); activeParticles.splice(i,1); continue; } const ps=s.geometry.attributes.position; const vs=s.geometry.attributes.velocity; for(let j=0;j<ps.count;j++){ const ix=j*3; const pST=s.geometry.attributes.startTime.array[j]; const pET=ct-pST; ps.array[ix]+=vs.array[ix]*dt; ps.array[ix+1]+=vs.array[ix+1]*dt-0.5*9.8*pET*dt; ps.array[ix+2]+=vs.array[ix+2]*dt; } ps.needsUpdate=true; s.material.opacity=0.8*(1.0-(et/s.lifespan)); s.material.needsUpdate=true; } }

        // --- Event Handlers --- (Unchanged)
        function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function onKeyDown(e){ if(e.key==='r'||e.key==='R'){restartMission();return;} if(e.key==='p'||e.key==='P'){togglePause();return;} if(isGameOver||isPaused||!currentPiece)return; switch(e.key){ case 'ArrowLeft':movePiece(-1,0,0);break; case 'ArrowRight':movePiece(1,0,0);break; case 'ArrowDown':if(currentFallSpeed!==FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_FAST;resetFallTimer();}movePiece(0,-1,0);break; case 'ArrowUp':rotatePieceY();break; case 'w':case 'W':movePiece(0,0,-1);break; case 's':case 'S':movePiece(0,0,1);break; } }
        function onKeyUp(e){ if(isGameOver||isPaused)return; if(e.key==='ArrowDown'){if(currentFallSpeed===FALL_SPEED_FAST){currentFallSpeed=FALL_SPEED_NORMAL;resetFallTimer();}} }

        // --- Animation Loop --- (Unchanged)
        function animate() { requestAnimationFrame(animate); const dt=clock.getDelta(); controls.update(); if(!isPaused){updateParticles(dt);} renderer.render(scene,camera); if(previewRenderer&&previewScene&&previewCamera){ if(previewPieceMesh&&!isPaused){previewPieceMesh.rotation.y+=0.01;} previewRenderer.render(previewScene,previewCamera); } }

        // --- Start the game ---
        init();

    </script>
</body>
</html>
